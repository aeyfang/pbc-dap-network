---
title: "network_visualization"
author: "Antoinette Fang"
date: "2025-04-29"
output: html_document
---
```{r}

# Load required packages
library(igraph)
library(ggraph)
library(RColorBrewer)
library(cowplot)
library(dplyr)
library(purrr)
theme_set(theme_cowplot())
edge_percent <- 1  # Controls proportion of edges to display
```

```{r data loading and prep}
# Load disease frequency and code reference data
disease_frequencies <- read.csv(paste0("./frequency tables/disease_frequencies_", 'unstrat', ".csv"))
disease_code <- read.csv(file = "./diseaseCodes.csv")

# Helper function to clean disease names for consistent reference
clean_disease_name <- function(name) {
  if(startsWith(name, "condition_")) {
    return(sub("^condition_", "", name))
  } else if(startsWith(name, "hs_cancer_types_")) {
    code <- disease_frequencies %>%
      filter(Code.from.DAP.data == name) %>%
      pull(Numerical.Codes)
    return(if(length(code) == 0) name else as.character(code))
  }
  return(name)
}

# Load significant disease pairs identified in our analysis
significant_pairs <- read.csv("./pair stats/significant_pairs_unstrat.csv")
formatted_significant_pairs <- significant_pairs %>%
  transmute(
    Disease1 = map_chr(Disease1, clean_disease_name),
    Disease2 = map_chr(Disease2, clean_disease_name),
    weight = AdjustedPValue
  ) %>%
  mutate(Disease1 = as.integer(Disease1),
         Disease2 = as.integer(Disease2))
```

```{r category definitions and connective analysis}
# Define primary disease categories of interest
most.prevalent.category <- c('Brain/Neurologic', 
                           'Cancer',
                           'Kidney/Urinary',
                           'Cardiac', 
                           'Gastrointestinal',
                           'Ear/Nose/Throat',
                           'Skin', 'Eye', 'Liver/Pancreas')

# Define color palette for category visualization
all.colors <- brewer.pal(length(most.prevalent.category)+2, 'Paired')
categoryLabels <- c(sort(most.prevalent.category), "Other")
names(all.colors) <- c(categoryLabels, 'Cross-category')  # Renamed from 'Yellow' for clarity

# Function to analyze category connectivity patterns
# This helps determine which categories should be collapsed in visualization
analyze_category_connectivity <- function(disease_pairs, disease_codes) {
  # Convert disease IDs to clean numerical codes
  formatted_pairs <- disease_pairs %>%
    transmute(
      Disease1 = Disease1,
      Disease2 = Disease2
    )
  
  # Get category for each disease
  disease_by_category <- disease_codes %>%
    mutate(code = as.integer(Numerical.Codes)) %>%
    dplyr::select(code, Disease.Category, Disease.Name)
  
  # Initialize results data frame
  category_connectivity <- data.frame(
    Category = character(),
    DiseaseCount = integer(),
    InternalConnections = integer(),
    ExternalConnections = integer(),
    ConnectionRatio = numeric(),
    stringsAsFactors = FALSE
  )
  
  # For each category, analyze connection patterns
  for (category in unique(disease_by_category$Disease.Category)) {
    # Get all diseases in this category
    category_diseases <- disease_by_category %>%
      filter(Disease.Category == category) %>%
      pull(code)
    
    # Count connections within and outside the category
    internal_connections <- 0
    external_connections <- 0
    
    for (i in 1:nrow(formatted_pairs)) {
      disease1 <- formatted_pairs$Disease1[i]
      disease2 <- formatted_pairs$Disease2[i]
      
      disease1_in_category <- disease1 %in% category_diseases
      disease2_in_category <- disease2 %in% category_diseases
      
      if (disease1_in_category && disease2_in_category) {
        # Both diseases are in this category
        internal_connections <- internal_connections + 1
      } else if (disease1_in_category || disease2_in_category) {
        # One disease is in this category, the other isn't
        external_connections <- external_connections + 1
      }
    }
    
    # Calculate connection ratio (internal / total)
    total_connections <- internal_connections + external_connections
    connection_ratio <- ifelse(total_connections > 0, 
                              internal_connections / total_connections, 
                              0)
    
    # Add to results
    category_connectivity <- rbind(category_connectivity, data.frame(
      Category = category,
      DiseaseCount = length(category_diseases),
      InternalConnections = internal_connections,
      ExternalConnections = external_connections,
      ConnectionRatio = connection_ratio,
      stringsAsFactors = FALSE
    ))
  }
  
  # Sort by connection ratio (descending)
  category_connectivity <- category_connectivity %>%
    arrange(desc(ConnectionRatio))
  
  return(category_connectivity)
}

# Use the function to analyze category connectivity
category_analysis <- analyze_category_connectivity(formatted_significant_pairs, disease_code)
```

```{r singleton analysis}
# Function to identify singletons in each category
# Singletons are diseases that only connect to diseases outside their category
identify_singletons <- function(disease_pairs, disease_codes) {
  # Get category for each disease
  disease_categories <- disease_codes %>%
    mutate(code = as.integer(Numerical.Codes)) %>%
    dplyr::select(code, Disease.Category, Disease.Name)
  
  # For each category, analyze disease connections
  singleton_analysis <- list()
  
  for (category in unique(disease_categories$Disease.Category)) {
    # Get all diseases in this category
    category_diseases <- disease_categories %>%
      filter(Disease.Category == category) %>%
      pull(code)
    
    # Skip categories with only one disease
    if (length(category_diseases) <= 1) {
      next
    }
    
    # For each disease in this category, analyze connections
    disease_connections <- data.frame()
    
    for (disease in category_diseases) {
      # Find all pairs where this disease appears
      disease_pairs_subset <- disease_pairs %>%
        filter(Disease1 == disease | Disease2 == disease)
      
      # Count connections to same category vs other categories
      internal_connections <- 0
      external_connections <- 0
      connected_diseases <- c()
      
      if (nrow(disease_pairs_subset) > 0) {
        for (i in 1:nrow(disease_pairs_subset)) {
          other_disease <- ifelse(
            disease_pairs_subset$Disease1[i] == disease, 
            disease_pairs_subset$Disease2[i], 
            disease_pairs_subset$Disease1[i]
          )
          
          other_category <- disease_categories %>%
            filter(code == other_disease) %>%
            pull(Disease.Category)
          
          if (other_category == category) {
            internal_connections <- internal_connections + 1
            connected_diseases <- c(connected_diseases, other_disease)
          } else {
            external_connections <- external_connections + 1
          }
        }
      }
      
      # Get disease name for reporting
      disease_name <- disease_categories %>%
        filter(code == disease) %>%
        pull(Disease.Name)
      
      # Add to results
      disease_connections <- rbind(disease_connections, data.frame(
        code = disease,
        name = disease_name,
        internal = internal_connections,
        external = external_connections,
        total = internal_connections + external_connections,
        is_singleton = (internal_connections == 0 & external_connections > 0),
        stringsAsFactors = FALSE
      ))
    }
    
    # Save results for this category
    singleton_analysis[[category]] <- disease_connections
  }
  
  return(singleton_analysis)
}

# Use the function to identify singletons
singleton_results <- identify_singletons(formatted_significant_pairs, disease_code)
```

```{r module definition for graph contraction}
# Define which categories to collapse based on connection ratio
collapse_threshold <- 0.3  # Categories with ratio > 0.3 will be collapsed

categories_to_collapse <- category_analysis %>%
  filter(ConnectionRatio >= collapse_threshold) %>%
  pull(Category)

# Prepare the module structure for graph contraction
# Initialize by setting each disease to its own module
disease_code_for_collapsing_groups <- disease_code %>%
  mutate(module = Numerical.Codes)

# For each category to collapse, set the module to a common value
for (category in categories_to_collapse) {
  # Find all diseases in this category
  category_diseases <- disease_code %>%
    filter(Disease.Category == category) %>%
    pull(Numerical.Codes)
  
  if (length(category_diseases) > 0) {
    # Get the prefix pattern for this category
    first_code <- as.character(category_diseases[1])
    prefix <- substr(first_code, 1, nchar(first_code) - 2)
    
    # Group these diseases by setting their module to a common value
    disease_code_for_collapsing_groups <- disease_code_for_collapsing_groups %>%
      mutate(module = ifelse(Disease.Category == category, 
                            as.numeric(paste0(prefix, "00")), 
                            module))
  }
}

# For categories we decided to collapse, handle singletons separately
for (category in categories_to_collapse) {
  if (category %in% names(singleton_results)) {
    singletons <- singleton_results[[category]] %>% filter(is_singleton == TRUE)
    
    if (nrow(singletons) > 0) {
      for (i in 1:nrow(singletons)) {
        # Keep this singleton separate
        singleton_code <- singletons$code[i]
        disease_code_for_collapsing_groups$module[
          disease_code_for_collapsing_groups$Numerical.Codes == singleton_code
        ] <- singleton_code
      }
    }
  }
}

# Create final modules structure for graph
modules <- disease_code_for_collapsing_groups %>%
  mutate('category' = Disease.Category) %>%
  mutate('code' = Numerical.Codes) %>%
  mutate('X' = NULL) %>%
  mutate("Numerical.Codes" = NULL) %>%
  mutate("Disease.Category" = NULL) %>%
  mutate('consolidated.category' = ifelse(category %in% most.prevalent.category, category, 'Other'))
```

```{r edge prep and color assignment}

# -------------------------------------------------------------------------
# EDGE PREPARATION AND COLOR ASSIGNMENT
# -------------------------------------------------------------------------

# Get the category for each disease in the edge list
temp1 <- dplyr::inner_join(
  formatted_significant_pairs,
  modules %>% 
    dplyr::select(c(code, consolidated.category)) %>% 
    dplyr::rename(Disease1 = code, category1=consolidated.category),
  by = 'Disease1'
) %>% dplyr::select(category1)

temp2 <- dplyr::inner_join(
  formatted_significant_pairs,
  modules %>% 
    dplyr::select(c(code, consolidated.category)) %>% 
    dplyr::rename(Disease2 = code, category2=consolidated.category),
  by = 'Disease2'
) %>% dplyr::select(category2)

# Combine the edge data with category information
formatted_significant_pairs <- cbind(formatted_significant_pairs, temp1, temp2)

# Set edge color based on whether the diseases are in the same category
formatted_significant_pairs$edge_color <- ifelse(
  formatted_significant_pairs$category1 == formatted_significant_pairs$category2, 
  as.character(formatted_significant_pairs$category1),
  'Cross-category'  # Renamed from 'Yellow' for clarity
)

# Save the full version before any subsetting
formatted_significant_pairs_full <- formatted_significant_pairs 

# Filter to include only the top edge_percent of edges (by significance)
formatted_significant_pairs <- formatted_significant_pairs_full %>% 
  dplyr::slice_min(
    order_by = weight, 
    n = round(nrow(formatted_significant_pairs)*edge_percent)
  )

```

```{r}
# Create the graph object with tidygraph
graph <- formatted_significant_pairs %>% 
  igraph::graph_from_data_frame() %>%
  tidygraph::as_tbl_graph(directed=FALSE) %>% 
  tidygraph::activate(nodes)

# Add node attributes to the graph
nodes.stat <- data.frame(code=as.integer(V(graph)$name)) %>% 
  left_join(modules, by = 'code') %>%
  left_join(disease_frequencies %>%
              mutate(code=Numerical.Codes) %>%
              dplyr::select(-Disease.Category),
            by = 'code')

V(graph)$consolidated.category <- nodes.stat$consolidated.category
V(graph)$category <- nodes.stat$category
V(graph)$prevalence <- nodes.stat$frequency

# Create informative node labels
# Category nodes show category name, individual nodes show disease name
V(graph)$hub <- ifelse(
  V(graph)$category %in% c(
    'Skin','Eye','Gastrointestinal','Cardiac', 'Mouth/Dental/Oral',
    'Respiratory','Bone/Orthopedic', 'Infection/Parasites','Trauma',
    'Toxin Consumption', 'Endocrine'
  ), 
  nodes.stat$category, 
  nodes.stat$Disease.Name.x
)

V(graph)$module <- as.numeric(as.factor(nodes.stat$module))
```

```{r graph contraction and visualization}
# Count the number of categories being collapsed for shape assignment
no.collapsed <- length(unique(modules$module[modules$module != modules$code]))

# Contract the graph based on modules
gn <- contract(graph, V(graph)$module, vertex.attr.comb=list(
  name = 'first',
  category = 'first',
  prevalence = 'sum',
  hub = 'first',
  module = 'ignore',
  consolidated.category = 'first'
))

# First, create a list of all module codes that represent collapsed categories
category_modules <- unique(modules$module[modules$code != modules$module])

# Add type attribute for node shapes (group vs single)
V(gn)$type <- c(rep('group', no.collapsed), rep('single', length(V(gn)$name) - no.collapsed))
my.shapes <- c(17, 16)  # Triangle for groups, circle for individual diseases
names(my.shapes) <- unique(V(gn)$type)

# Create the final visualization
p3 <- ggraph(gn, layout=layout_nicely(gn)) + 
  # Draw edges colored by disease category
  geom_edge_link(aes(color=edge_color, width=min(10, 0.1 + 1/(weight+0.0001)))) + 
  scale_edge_width(range = c(0.1, 1.5), guide = "none") +
  scale_edge_colour_manual(values=all.colors, name="Connection Type") +
  geom_node_point(aes(color=consolidated.category, size=prevalence, shape=type)) +
  scale_shape_manual(values=my.shapes, name="Node Type",
                   labels=c("Category Group", "Individual Disease")) + 
  scale_size_continuous(name="Disease Prevalence", range=c(2, 10)) +
  # Add labels with repulsion to avoid overlap
  geom_node_text(aes(label=hub), repel=TRUE, size=3) +
  # Customize theme and add title
  theme_minimal() +
  theme(
    legend.position = "right",
    legend.box = "vertical",
    plot.title = element_text(hjust = 0.5, size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 10)
  ) +
  labs(
    title = "Canine Comorbidity Network",
    subtitle = "Node size = prevalence, Edge width = strength of association",
    caption = "All connections significant at p < 0.001 (Bonferroni-adjusted)"
  )

# Display and save the plot
p3
save_plot("./comorbidity_network.png", p3, base_height = 8, base_width = 10)


```





