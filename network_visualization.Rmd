---
title: "network_visualization"
author: "Antoinette Fang"
date: "2025-04-29"
output: html_document
---

```{r setup}
# Load required packages for network visualization
library(igraph)       # Network graph creation and manipulation
library(ggraph)       # Grammar of graphics for network visualization
library(RColorBrewer) # Color palettes for network categories
library(cowplot)      # Plot composition and layout
library(tidyverse)    # Data manipulation
library(tidygraph)    # Tidy graph data structures
library(patchwork)    # Additional plot composition

# Create necessary output directories
dir.create("./network images", showWarnings = FALSE, recursive = TRUE)
```

```{r load precomputed data}
# Load pre-computed analysis results from previous scripts
# Main network data
significant_pairs <- read.csv("./pair stats/significant_pairs_unstrat.csv")
disease_code <- read.csv("./diseaseCodes.csv")
disease_frequencies <- read.csv("./frequency tables/disease_frequencies_unstrat.csv")

# Age-stratified network data
significant_pairs_ya <- read.csv("./pair stats/significant_pairs_young_adult.csv")
disease_frequencies_ya <- read.csv("./frequency tables/disease_frequencies_young_adult.csv")

significant_pairs_ma <- read.csv("./pair stats/significant_pairs_mature_adult.csv")
disease_frequencies_ma <- read.csv("./frequency tables/disease_frequencies_mature_adult.csv")

significant_pairs_s <- read.csv("./pair stats/significant_pairs_senior.csv")
disease_frequencies_s <- read.csv("./frequency tables/disease_frequencies_senior.csv")

# Load directed network significant pairs (12-month window)
significant_pairs_directed <- read.csv("./pair stats/significant_pairs_directed_12m.csv") %>%
  rename(from = source, to = target)

# Extract edges for directed network
edges_directed <- significant_pairs_directed %>% dplyr::select(from, to)

# Load previously created figure
p_heatmap <- readRDS("./network tables/network_overlap_heatmap.rds")
```

```{r visualization constants}
# Define consistent visual elements across all network plots
# This ensures all networks use the same color scheme and styling

# Calculate frequency ranges for consistent node sizing across all networks
all_frequencies <- c(disease_frequencies$frequency)
freq_min <- min(all_frequencies, na.rm = TRUE)
freq_max <- max(all_frequencies, na.rm = TRUE)

# Disease name replacements for better readability in plots
label_replacements <- c(
  "Keratoconjunctivitis sicca (KCS)" = "Keratoconjunctivitis sicca",
  "Hypertension (high blood pressure)" = "Hypertension",
  "Lameness (chronic or recurrent)" = "Lameness",
  "Bordatella and/or parainfluenza (kennel cough)" = "Bordatella/parainfluenza",
  "Bordetella and/or parainfluenza (kennel cough)" = "Bordatella/parainfluenza",
  "Cushing's disease (hyperadrenocorticism; excess adrenal function)" = "Cushing's disease",
  "Addison's disease (hypoadrenocorticism; low adrenal function)" = "Addison's disease",
  "Diabetes mellitus (common diabetes which causes high blood sugar)" = "Diabetes mellitus",
  "Penetrating wound (such as a stick)" = "Penetrating wound",
  "Head trauma due to any cause" = "Head trauma",
  "Chronic or recurrent cough" = "Chronic/recurrent cough",
  "Chronic or recurrent bronchitis" = "Chronic/recurrent bronchitis",
  "Tracheal stenosis (narrowing)" = "Tracheal stenosis",
  "Dental calculus (yellow build-up on teeth)" = "Dental calculus",
  "Gingivitis (red, puffy gums)" = "Gingivitis",
  "Retained deciduous (baby) teeth" = "Retained deciduous teeth",
  "Hearing loss (incompletely deaf)" = "Hearing loss",
  "Urinary tract infection (chronic or recurrent)" = "Urinary tract infection",
  "Urinary crystals or stones in bladder or urethra" = "Urinary crystals/stones",
  "Alopecia (hair loss)" = "Alopecia",
  "Atopic dermatitis (atopy)" = "Atopic dermatitis",
  "Pruritis (itchy skin)" = "Pruritis",
  "Chronic or recurrent hot spots" = "Chronic/recurrent hot spots",
  "Chronic or recurrent skin infections" = "Chronic/recurrent skin infections",
  "Food or medicine allergies that affect the skin" = "Skin food/medicine allergies",
  "Food or medicine allergies" = " Gastrointestinal food/medicine allergies",
  "Chronic or recurrent diarrhea" = "Chronic/recurrent diarrhea",
  "Chronic or recurrent vomiting" = "Chronic/recurrent vomiting",
  "Hemorrhagic gastroenteritis (HGE) or stress colitis (acute)" = "Hemorrhagic gastroenteritis or stress colitis",
  "Seborrhea or seborrheic dermatitis (greasy skin)" = "Seborrhea or seborrheic dermatitis",
  "Other ToxinConsumption" = "Other toxin consumption",
  "Ear Mites" = "Ear mites"
)

# Define consistent category palette for all networks
fixed_categories <- c(
  "Eye", "Ear/Nose/Throat", "Mouth/Dental/Oral", "Skin", "Respiratory",
  "Gastrointestinal", "Bone/Orthopedic", "Cardiac",
  "Infection/Parasites", "Trauma", "Kidney/Urinary", "Other"
)

category_palette <- setNames(
  RColorBrewer::brewer.pal(length(fixed_categories), "Paired"),
  fixed_categories
)

# Override the color for "Kidney/Urinary" for better contrast
category_palette["Kidney/Urinary"] <- "black"

cat("Visualization constants defined:",
    "\nFrequency range:", freq_min, "to", freq_max,
    "\nColor categories:", length(fixed_categories),
    "\nLabel replacements:", length(label_replacements), "\n")
```

```{r helper functions}
# Utility functions for consistent network visualization processing

# Function to clean disease names and convert to numerical codes
clean_disease_name <- function(name) {
  if (startsWith(name, "condition_")) {
    sub("^condition_", "", name)
  } else if (startsWith(name, "hs_cancer_types_")) {
    code <- disease_frequencies %>%
      filter(Code.from.DAP.data == name) %>%
      pull(Numerical.Codes)
    if (length(code) == 0) name else as.character(code)
  } else {
    name
  }
}

```

```{r unstratified network main graph}
# Create the main unstratified network with node collapsing and highlighting
# This creates the primary visualization showing collapsed disease categories

# Format significant pairs for visualization
formatted_significant_pairs <- significant_pairs %>%
  transmute(
    Disease1 = map_chr(Disease1, clean_disease_name),
    Disease2 = map_chr(Disease2, clean_disease_name)
  ) 

# Create initial graph from formatted pairs
graph <- graph_from_data_frame(formatted_significant_pairs, directed = FALSE)

# Prepare node category mapping
node_categories <- disease_code %>%
  dplyr::mutate(node_id = as.character(Numerical.Codes)) %>%
  dplyr::select(node_id, Disease.Category)

# Identify singleton nodes within each category
# These are nodes that have no connections within their own category
singleton_nodes <- list()

for (category in unique(node_categories$Disease.Category)) {
  category_nodes <- node_categories %>%
    filter(Disease.Category == category) %>%
    pull(node_id)

  subgraph <- induced_subgraph(graph, which(V(graph)$name %in% category_nodes))

  for (node in V(subgraph)$name) {
    if (degree(subgraph, node) == 0 && degree(graph, node) > 0) {
      singleton_nodes[[category]] <- c(singleton_nodes[[category]], node)
    }
  }
}

# Define nodes to keep as individuals (high importance nodes)
excluded_nodes <- c("101", "102", "404", "514", "908", "911", "1305", "1307", "1407", "202")
individual_nodes <- c(unlist(singleton_nodes), excluded_nodes)

# Define categories to collapse into aggregate nodes
collapse_categories <- c(
  "Eye", "Ear/Nose/Throat", "Mouth/Dental/Oral", "Skin", "Respiratory",
  "Gastrointestinal", "Bone/Orthopedic", "Toxin Consumption",
  "Infection/Parasites", "Trauma"
)

# Create node mapping for collapsing
unique_nodes <- unique(c(formatted_significant_pairs$Disease1, formatted_significant_pairs$Disease2))

node_mapping <- node_categories %>%
  filter(node_id %in% unique_nodes) %>%
  dplyr::mutate(
    collapse_category = case_when(
      node_id %in% individual_nodes ~ node_id,
      Disease.Category %in% collapse_categories ~ Disease.Category,
      TRUE ~ node_id
    )
  ) %>%
  left_join(
    disease_frequencies %>%
      dplyr::mutate(Numerical.Codes = as.character(Numerical.Codes)) %>%
      dplyr::select(Numerical.Codes, Disease.Name, frequency),
    by = c("node_id" = "Numerical.Codes")
  ) %>%
  dplyr::select(node_id, collapse_category, Disease.Name, frequency)

# Add collapse category and frequency to graph vertices
V(graph)$collapse_category <- node_mapping$collapse_category[match(V(graph)$name, node_mapping$node_id)]
V(graph)$frequency <- node_mapping$frequency[match(V(graph)$name, node_mapping$node_id)]

# Contract graph to create collapsed nodes
group_ids <- as.numeric(as.factor(V(graph)$collapse_category))

collapsed_graph <- contract(
  graph,
  mapping = group_ids,
  vertex.attr.comb = list(
    frequency = "sum",
    collapse_category = "first"
  )
)

cat("Graph collapsing completed:",
    "\nOriginal nodes:", vcount(graph),
    "\nCollapsed nodes:", vcount(collapsed_graph), "\n")
```

```{r unstratified network attributes}
# Add comprehensive attributes to the collapsed network
# This includes labels, node types, and display categories

# Create labels for individual nodes
individual_names <- node_mapping %>%
  filter(collapse_category == node_id) %>%
  dplyr::select(collapse_category, Disease.Name)

# Create labels for aggregate categories
aggregate_categories <- setdiff(
  unique(V(collapsed_graph)$collapse_category),
  individual_names$collapse_category
)

aggregate_names <- data.frame(
  collapse_category = aggregate_categories,
  Disease.Name = aggregate_categories,
  stringsAsFactors = FALSE
)

# Combine all labels
complete_mapping <- bind_rows(individual_names, aggregate_names)

V(collapsed_graph)$Disease.Name <- complete_mapping$Disease.Name[
  match(V(collapsed_graph)$collapse_category, complete_mapping$collapse_category)
]

# Add metadata about collapsed nodes
collapsed_sizes <- node_mapping %>%
  group_by(collapse_category) %>%
  summarise(num_diseases_collapsed = n(), .groups = "drop")

V(collapsed_graph)$num_diseases_collapsed <- collapsed_sizes$num_diseases_collapsed[
  match(V(collapsed_graph)$collapse_category, collapsed_sizes$collapse_category)
]

original_ids <- node_mapping %>%
  group_by(collapse_category) %>%
  summarise(original_node_ids = paste(node_id, collapse = ", "), .groups = "drop")

V(collapsed_graph)$original_node_ids <- original_ids$original_node_ids[
  match(V(collapsed_graph)$collapse_category, original_ids$collapse_category)
]

# Assign node type (individual vs aggregate)
V(collapsed_graph)$node_type <- ifelse(
  V(collapsed_graph)$collapse_category %in% individual_names$collapse_category,
  "individual", "aggregate"
)

V(collapsed_graph)$is_aggregate <- V(collapsed_graph)$node_type == "aggregate"

# Assign display categories for coloring
individual_display_category <- node_mapping %>%
  filter(collapse_category == node_id) %>%
  left_join(node_categories, by = "node_id") %>%
  dplyr::select(collapse_category, display_category = Disease.Category)

aggregate_display_category <- data.frame(
  collapse_category = aggregate_categories,
  display_category = aggregate_categories,
  stringsAsFactors = FALSE
)

category_mapping <- bind_rows(individual_display_category, aggregate_display_category)

V(collapsed_graph)$display_category <- category_mapping$display_category[
  match(V(collapsed_graph)$collapse_category, category_mapping$collapse_category)
]

V(collapsed_graph)$original_display_category <- V(collapsed_graph)$display_category

# Define categories to preserve their specific colors
preserve_color_categories <- c(collapse_categories, "Kidney/Urinary")

V(collapsed_graph)$display_category <- ifelse(
  V(collapsed_graph)$display_category %in% preserve_color_categories,
  V(collapsed_graph)$display_category,
  "Other"
)

cat("Network attributes assigned:",
    "\nIndividual nodes:", sum(V(collapsed_graph)$node_type == "individual"),
    "\nAggregate nodes:", sum(V(collapsed_graph)$node_type == "aggregate"), "\n")
```

```{r unstratified network styling}
# Apply visual styling and create the main network plot
# This includes edge highlighting and proper node shapes

# Prepare vertex table for cleaner processing
vertices <- data.frame(
  id = seq_along(V(collapsed_graph)),
  collapse_category = V(collapsed_graph)$collapse_category,
  display_category = V(collapsed_graph)$display_category,
  original_display_category = V(collapsed_graph)$original_display_category,
  Disease.Name = V(collapsed_graph)$Disease.Name,
  node_type = V(collapsed_graph)$node_type,
  is_aggregate = V(collapsed_graph)$is_aggregate,
  num_diseases_collapsed = V(collapsed_graph)$num_diseases_collapsed,
  original_node_ids = V(collapsed_graph)$original_node_ids,
  frequency = V(collapsed_graph)$frequency
)

# Rebuild clean graph from edgelist
edges_raw <- as_edgelist(collapsed_graph, names = FALSE)
clean_graph <- graph_from_edgelist(edges_raw, directed = FALSE)

# Re-attach all attributes
for (attr in names(vertices)[-1]) {
  vertex_attr(clean_graph, attr) <- vertices[[attr]]
}

# Apply label replacements for better readability
V(clean_graph)$Disease.Name <- dplyr::recode(
  V(clean_graph)$Disease.Name,
  !!!label_replacements
)

# Set font styling: italic for aggregate nodes
V(clean_graph)$fontface <- ifelse(
  V(clean_graph)$node_type == "aggregate",
  "italic", "plain"
)

# Remove duplicate edges safely
clean_graph <- simplify(
  clean_graph,
  remove.multiple = TRUE,
  remove.loops = TRUE,
  edge.attr.comb = list(
    edge_category = function(x) unique(x)[1],
    is_important = any,
    width = max,
    linetype = function(x) if ("11" %in% x) "11" else "solid",
    "ignore" = "first"
  )
)

# Classify edge categories based on original node categories
node_cat_orig <- V(clean_graph)$original_display_category
edge_pairs <- igraph::ends(clean_graph, E(clean_graph), names = FALSE)

E(clean_graph)$edge_category <- apply(edge_pairs, 1, function(pair) {
  cat1 <- node_cat_orig[pair[1]]
  cat2 <- node_cat_orig[pair[2]]

  if (cat1 == cat2) {
    if (cat1 %in% preserve_color_categories) {
      cat1
    } else {
      "Other"
    }
  } else {
    "Cross-category"
  }
})

# Highlight manuscript-discussed edges
important_pairs <- list(
  c("1307", "101"),   # Diabetes – Blindness
  c("1305", "404"),   # Cushing's – Alopecia
  c("514", "908"),    # Hypertension – CKD
  c("911", "1407"),   # Proteinuria – Anemia
  c("908", "911")     # CKD – Proteinuria
)

# Convert to collapse category strings for matching
id_to_cat <- setNames(node_mapping$collapse_category, node_mapping$node_id)
important_strs <- map_chr(
  map(important_pairs, ~ sort(id_to_cat[.x])),
  paste, collapse = "_"
)

# Match edge pairs to highlight important connections
vertex_cat <- V(clean_graph)$collapse_category
edge_cats <- apply(ends(clean_graph, E(clean_graph), names = FALSE), 1, function(pair) {
  sort(vertex_cat[pair])
})
edge_strs <- apply(edge_cats, 2, paste, collapse = "_")

E(clean_graph)$is_important <- edge_strs %in% important_strs

# Special case: highlight ear infection (202) to skin aggregate connection
v_skin <- which(V(clean_graph)$collapse_category == "Skin")
v_202  <- which(V(clean_graph)$collapse_category == "202")
edge_idx <- get_edge_ids(clean_graph, c(v_202, v_skin))

if (edge_idx > 0) {
  E(clean_graph)$is_important[edge_idx] <- TRUE
  message("Edge from node 202 to Skin marked as important.")
} else {
  warning("Edge between 202 and Skin not found.")
}

cat("Network styling completed:",
    "\nImportant edges highlighted:", sum(E(clean_graph)$is_important),
    "\nEdge categories assigned\n")
```

```{r create main network plot}
# Create the main collapsed network visualization
# This is the primary figure showing the full comorbidity network

# Build tidygraph layout
graph_tbl <- as_tbl_graph(clean_graph)
layout_tbl <- create_layout(graph_tbl, layout = "fr") %>%
  dplyr::mutate(
    node_shape = factor(ifelse(is_aggregate, 21, 16), levels = c(16, 21)),
    node_fill = ifelse(is_aggregate, NA, alpha("white", 0.6))
  )

# Define edge color palette including cross-category
edge_palette <- c(category_palette, "Cross-category" = "grey38")

# Create the main network plot
p <- ggraph(layout_tbl) +
  geom_edge_link(
    aes(
      color = edge_category,
      linetype = is_important,
      width = is_important
    ),
    alpha = 0.6
  ) +
  geom_node_point(
  aes(
    size = frequency,
    color = display_category,
    shape = node_shape
  ),
  fill = alpha("white", 0.6),
  stroke = 1.5
) +
  geom_node_label(
    aes(label = Disease.Name, fontface = fontface),
    repel = TRUE,
    label.size = 0.3,
    max.overlaps = Inf,
    label.r = unit(0.15, "lines"),
    fill = alpha("white", 0.7),
    color = "black",
    size = 3.5
  ) +
  scale_edge_color_manual(
    values = edge_palette,
    name = "Edge Category") +
  scale_edge_linetype_manual(
    values = c("TRUE" = "11", "FALSE" = "solid"),
    name = "Highlighted"
  ) +
  scale_edge_width_manual(
    values = c("TRUE" = 2, "FALSE" = 0.5),
    guide = "none"
  ) +
  scale_shape_manual(
  values = c(`16` = 16, `21` = 21),
  name = "Node Type",
  labels = c(`16` = "individual", `21` = expression(italic("aggregate")))
) +
  scale_color_manual(
  values = category_palette,
  name = "Node Category",
  guide = guide_legend(override.aes = list(shape = 16))
) +
  scale_fill_manual(
  values = c(category_palette, NA),
  na.value = NA,
  guide = "none"
) +
  scale_size_continuous(
    name = "Frequency",
    limits = c(freq_min, freq_max),
    range = c(3, 9),
    breaks = c(500, 1000, 2000, 5000, 10000)
  ) +
  theme_void()

# Save main network plot
ggsave(
  filename = "./network images/undirected_network_graph.png",
  plot = p,
  dpi = 600,
  width = 10,
  height = 9,
  units = "in"
)

print(p)
```
```{r ear infection subgraph}
# Create detailed subgraph showing ear infection connections
# This provides a focused view of one important disease and its neighbors

# Define the target node (ear infection)
target_node <- "202"

# Ensure node exists in the original graph
if (!(target_node %in% V(graph)$name)) {
  stop("Node 202 not found in the graph.")
}

# Get first-degree neighbors of ear infection
neighbor_ids <- neighbors(graph, v = target_node, mode = "all")
subgraph_nodes <- c(target_node, V(graph)$name[neighbor_ids])

# Create the ear infection subgraph
ear_infection_subgraph <- induced_subgraph(graph, vids = subgraph_nodes)

# Add display category attributes
V(ear_infection_subgraph)$display_category <- node_mapping$collapse_category[
  match(V(ear_infection_subgraph)$name, node_mapping$node_id)
]

# Force correct display category for ear infection node
V(ear_infection_subgraph)$display_category[V(ear_infection_subgraph)$name == "202"] <- "Ear/Nose/Throat"

# Add disease names and frequencies
V(ear_infection_subgraph)$Disease.Name <- node_mapping$Disease.Name[
  match(V(ear_infection_subgraph)$name, node_mapping$node_id)
]

V(ear_infection_subgraph)$frequency <- node_mapping$frequency[
  match(V(ear_infection_subgraph)$name, node_mapping$node_id)
]

# Apply label replacements to disease names in subgraph
V(ear_infection_subgraph)$Disease.Name <- dplyr::recode(
  V(ear_infection_subgraph)$Disease.Name,
  !!!label_replacements
)

# Assign edge categories consistent with main graph
edge_pairs <- igraph::ends(ear_infection_subgraph, E(ear_infection_subgraph), names = FALSE)
node_cats <- V(ear_infection_subgraph)$display_category

E(ear_infection_subgraph)$edge_category <- apply(edge_pairs, 1, function(pair) {
  cat1 <- node_cats[pair[1]]
  cat2 <- node_cats[pair[2]]
  if (!is.na(cat1) && !is.na(cat2) && cat1 == cat2) {
    return(cat1)
  } else {
    return("Cross-category")
  }
})

# Ensure factor levels align with main palette
E(ear_infection_subgraph)$edge_category <- factor(
  E(ear_infection_subgraph)$edge_category,
  levels = c(names(category_palette), "Cross-category")
)

# Prepare layout and create subgraph plot
tg_sub <- as_tbl_graph(ear_infection_subgraph) %>%
  dplyr::mutate(
    frequency = ifelse(is.na(frequency), 1, frequency),
    fontface = "plain"
  )

layout_sub <- create_layout(tg_sub, layout = "kk")

p_sub <- ggraph(layout_sub) +
  geom_edge_link(
    aes(color = edge_category),
    alpha = 0.6
  ) +
  geom_node_point(
    aes(
      size = frequency,
      color = display_category
    ),
    shape = 16,
    alpha = 0.9
  ) +
  geom_node_label(
    aes(label = Disease.Name, fontface = fontface),
    repel = TRUE,
    label.size = 0.3,
    label.r = unit(0.15, "lines"),
    fill = alpha("white", 0.7),
    color = "black",
    size = 4
  ) +
  scale_color_manual(values = category_palette, name = "Node Category") +
  scale_edge_color_manual(
    values = c(category_palette, "Cross-category" = "grey38"),
    name = "Edge Category"
  ) +
  scale_size_continuous(
  name = "Frequency",
  limits = c(freq_min, freq_max),
  range = c(3, 9),
  breaks = c(500, 1000, 2000, 5000, 10000)
) +
  theme_void()


# Save main network plot
ggsave(
  filename = "./network images/ear_infection_subgraph.png",
  plot = p_sub,
  dpi = 600,
  width = 10,
  height = 9,
  units = "in"
)

cat("Ear infection subgraph created:",
    "\nSubgraph nodes:", vcount(ear_infection_subgraph),
    "\nSubgraph edges:", ecount(ear_infection_subgraph), "\n")

print(p_sub)
```

```{r combined main figure}
# Create the main publication figure combining full network and subgraph
# This shows both the overall network structure and detailed view

# Extract legend from the full graph plot
legend_full <- get_legend(
  p +
    theme(
      legend.position = "right",
      legend.box = "vertical",
      legend.title = element_text(size = 16), 
      legend.text = element_text(size = 14)
    )
)

# Remove legends from plots for clean composition
p_nolegend <- p + theme(legend.position = "none")
p_sub_nolegend <- p_sub + theme(legend.position = "none")

# Create left column with proper spacing and labels
left_column <- plot_grid(
  plot_spacer(),     # Top padding
  p_nolegend,
  plot_spacer(),     # Between full and subgraph
  p_sub_nolegend,
  plot_spacer(),     # Bottom padding
  ncol = 1,
  rel_heights = c(0.03, 0.57, 0.03, 0.32, 0.05),
  labels = c("", "a)", "", "b)", ""),
  label_x = 0.02,
  label_y = 1,
  hjust = 0,
  vjust = 1,
  label_size = 20
)

# Create final 2-column layout with shared legend
final_layout <- plot_grid(
  left_column,
  legend_full,
  ncol = 2,
  rel_widths = c(0.7, 0.3)
)

print(final_layout)

# Save combined main figure
ggsave(
  filename = "./network images/final_network_layout.png",
  plot = final_layout,
  dpi = 600,
  width = 12,
  height = 15,
  units = "in"
)

ggsave(
  filename = "./network images/final_network_layout.tiff",
  plot = final_layout,
  dpi = 600,
  width = 12,
  height = 15,
  units = "in",
  compression = "lzw"
)
```

```{r young adult network}
# Create young adult network visualization
# Shows comorbidity patterns in early adult life stage with all nodes labeled

# Clean disease IDs for young adult network
significant_pairs_ya <- significant_pairs_ya %>%
  dplyr::mutate(
    Disease1 = map_chr(Disease1, clean_disease_name),
    Disease2 = map_chr(Disease2, clean_disease_name)
  )

# Extract unique disease codes for this network
young_disease_ids <- unique(c(
  significant_pairs_ya$Disease1,
  significant_pairs_ya$Disease2
))

# Prepare node metadata for young adult network
node_info_ya <- disease_code %>%
  dplyr::mutate(node_id = as.character(Numerical.Codes)) %>%
  filter(node_id %in% young_disease_ids) %>%
  dplyr::select(
    node_id,
    category = Disease.Category,
    disease_name = Disease.Name
  ) %>%
  left_join(
    disease_frequencies_ya %>%
      dplyr::mutate(node_id = as.character(Numerical.Codes)) %>%
      dplyr::select(node_id, frequency),
    by = "node_id"
  ) %>%
  dplyr::mutate(
    # Reclassify toxin consumption as "Other" for consistency
    category = ifelse(category == "Toxin consumption", "Other", category)
  )

# Build graph from young adult pairs
graph_ya <- graph_from_data_frame(significant_pairs_ya, directed = FALSE)

# Assign vertex attributes from metadata
V(graph_ya)$disease_name <- node_info_ya$disease_name[
  match(V(graph_ya)$name, node_info_ya$node_id)
]

V(graph_ya)$category <- node_info_ya$category[
  match(V(graph_ya)$name, node_info_ya$node_id)
]

V(graph_ya)$frequency <- node_info_ya$frequency[
  match(V(graph_ya)$name, node_info_ya$node_id)
]

# Apply label replacements for better readability
V(graph_ya)$disease_name <- dplyr::recode(
  V(graph_ya)$disease_name,
  !!!label_replacements
)

# Assign node labels (label all nodes in young adult network)
node_labels_ya <- disease_frequencies_ya$Disease.Name[
  match(V(graph_ya)$name, as.character(disease_frequencies_ya$Numerical.Codes))
]

node_labels_ya <- dplyr::recode(node_labels_ya, !!!label_replacements)
V(graph_ya)$label <- node_labels_ya

# Compute edge categories for young adult network
node_cat_ya <- V(graph_ya)$category
edge_pairs_ya <- igraph::ends(graph_ya, E(graph_ya), names = FALSE)

edge_category_ya <- apply(edge_pairs_ya, 1, function(pair) {
  cat1 <- node_cat_ya[pair[1]]
  cat2 <- node_cat_ya[pair[2]]
  if (cat1 == cat2) cat1 else "Cross-category"
})

E(graph_ya)$edge_category <- edge_category_ya

# Convert to tidygraph and attach vertex attributes
graph_tbl_ya <- as_tbl_graph(graph_ya) %>%
  activate(edges) %>%
  dplyr::mutate(edge_category = edge_attr(graph_ya, "edge_category")) %>%
  activate(nodes) %>%
  dplyr::mutate(
    disease_name = V(graph_ya)$disease_name,
    frequency = V(graph_ya)$frequency,
    category = V(graph_ya)$category,
    label = V(graph_ya)$label
  )

# Create layout for young adult network
layout_matrix_ya <- layout_with_fr(graph_ya)

graph_tbl_ya_layout <- create_layout(
  graph_tbl_ya,
  layout = "manual",
  x = layout_matrix_ya[, 1],
  y = layout_matrix_ya[, 2]
)

# Create young adult network plot
p_ya <- ggraph(graph_tbl_ya_layout) +
  geom_edge_link(aes(color = edge_category), alpha = 0.5) +
  geom_node_point(
    aes(size = frequency, color = category),
    shape = 16
  ) +
  geom_node_label(
    aes(label = label),
    repel = TRUE,
    label.size = 0.3,
    max.overlaps = Inf,
    label.r = unit(0.15, "lines"),
    fill = alpha("white", 0.7),
    color = "black",
    size = 4
  ) +
  scale_color_manual(
    values = category_palette,
    breaks = sort(names(category_palette)),
    name = "Node Category"
  ) +
  scale_edge_color_manual(
    values = c(category_palette, "Cross-category" = "grey38"),
    breaks = c(sort(names(category_palette)), "Cross-category"),
    name = "Edge Category"
  ) +
  scale_size_continuous(
    name = "Frequency",
    limits = c(freq_min, freq_max),
    range = c(4, 9),
    breaks = c(500, 1000, 2000, 5000, 10000)
  ) +
  theme_void() +
  theme(
    legend.text = element_text(size = 12),
    legend.title = element_text(size = 14)
  )

# Save young adult network plot
ggsave(
  filename = "./network images/young_adult_network_graph.png",
  plot = p_ya,
  dpi = 600,
  width = 10,
  height = 8,
  units = "in"
)

print(p_ya)

cat("Young adult network visualization completed:",
    "\nNodes:", vcount(graph_ya),
    "\nEdges:", ecount(graph_ya), "\n")
```

```{r mature adult collapsed network}
# Create mature adult network with skin and infection/parasites collapsed
# Shows intermediate life stage patterns with strategic node grouping

# Clean and filter significant pairs for mature adult network
raw_pairs_ma <- significant_pairs_ma %>%
  dplyr::mutate(
    Disease1 = map_chr(Disease1, clean_disease_name),
    Disease2 = map_chr(Disease2, clean_disease_name)
  )

# Build graph from mature adult pairs
raw_graph_ma <- graph_from_data_frame(raw_pairs_ma, directed = FALSE)

# Assign node attributes from frequency data
raw_categories_ma <- disease_frequencies_ma$Disease.Category[
  match(V(raw_graph_ma)$name, as.character(disease_frequencies_ma$Numerical.Codes))
]

V(raw_graph_ma)$display_category <- ifelse(
  raw_categories_ma %in% fixed_categories,
  raw_categories_ma,
  "Other"
)

V(raw_graph_ma)$frequency <- disease_frequencies_ma$frequency[
  match(V(raw_graph_ma)$name, as.character(disease_frequencies_ma$Numerical.Codes))
]

# Get node labels and apply replacements
node_labels_ma <- disease_frequencies_ma$Disease.Name[
  match(V(raw_graph_ma)$name, as.character(disease_frequencies_ma$Numerical.Codes))
]

node_labels_ma <- dplyr::recode(node_labels_ma, !!!label_replacements)
V(raw_graph_ma)$label <- node_labels_ma

# Define categories to collapse in mature adult network
collapse_categories_ma <- c("Skin", "Infection/Parasites")

node_id_ma <- V(raw_graph_ma)$name
collapse_category_ma <- ifelse(
  raw_categories_ma %in% collapse_categories_ma,
  raw_categories_ma,
  node_id_ma
)

V(raw_graph_ma)$collapse_category <- collapse_category_ma

# Contract graph to create collapsed nodes
group_ids_ma <- as.numeric(as.factor(collapse_category_ma))

collapsed_graph_ma <- contract(
  raw_graph_ma,
  mapping = group_ids_ma,
  vertex.attr.comb = list(
    frequency = "sum",
    display_category = "first",
    collapse_category = "first",
    label = function(x) x[1]
  )
)

V(collapsed_graph_ma)$name <- V(collapsed_graph_ma)$collapse_category

# Build labels for collapsed mature adult network
individual_names_ma <- tibble(
  collapse_category = node_id_ma,
  label = node_labels_ma
) %>%
  filter(collapse_category == collapse_category_ma)

aggregate_categories_ma <- setdiff(
  unique(V(collapsed_graph_ma)$collapse_category),
  individual_names_ma$collapse_category
)

aggregate_names_ma <- tibble(
  collapse_category = aggregate_categories_ma,
  label = aggregate_categories_ma
)

complete_labels_ma <- bind_rows(individual_names_ma, aggregate_names_ma)

V(collapsed_graph_ma)$label <- complete_labels_ma$label[
  match(V(collapsed_graph_ma)$collapse_category, complete_labels_ma$collapse_category)
]

# Style nodes based on type (individual vs aggregate)
V(collapsed_graph_ma)$node_type <- ifelse(
  V(collapsed_graph_ma)$collapse_category %in% collapse_categories_ma,
  "aggregate", "individual"
)

V(collapsed_graph_ma)$fontface <- ifelse(
  V(collapsed_graph_ma)$node_type == "aggregate",
  "italic", "plain"
)

V(collapsed_graph_ma)$node_shape <- ifelse(
  V(collapsed_graph_ma)$node_type == "aggregate",
  21, 16
)

# Add collapse metadata for reference
collapse_map_tbl <- tibble(
  node_id = node_id_ma,
  collapse_category = collapse_category_ma
)

collapsed_sizes_ma <- collapse_map_tbl %>%
  group_by(collapse_category) %>%
  summarise(num_diseases_collapsed = n(), .groups = "drop")

original_ids_ma <- collapse_map_tbl %>%
  group_by(collapse_category) %>%
  summarise(original_node_ids = paste(node_id, collapse = ", "), .groups = "drop")

V(collapsed_graph_ma)$num_diseases_collapsed <- collapsed_sizes_ma$num_diseases_collapsed[
  match(V(collapsed_graph_ma)$collapse_category, collapsed_sizes_ma$collapse_category)
]

V(collapsed_graph_ma)$original_node_ids <- original_ids_ma$original_node_ids[
  match(V(collapsed_graph_ma)$collapse_category, original_ids_ma$collapse_category)
]

# Compute edge categories safely
edge_pairs_ma <- igraph::ends(collapsed_graph_ma, E(collapsed_graph_ma), names = FALSE)

edge_categories_ma <- apply(edge_pairs_ma, 1, function(pair) {
  cat1 <- V(collapsed_graph_ma)$display_category[pair[1]]
  cat2 <- V(collapsed_graph_ma)$display_category[pair[2]]

  if (is.na(cat1) || is.na(cat2)) {
    return("Unknown")
  }

  if (cat1 == cat2) cat1 else "Cross-category"
})

E(collapsed_graph_ma)$edge_category <- edge_categories_ma

# Create layout and tidygraph representation
layout_matrix_ma_collapsed <- layout_with_fr(collapsed_graph_ma)

graph_tbl_ma_collapsed <- as_tbl_graph(collapsed_graph_ma) %>%
  activate(nodes) %>%
  dplyr::mutate(
    frequency = V(collapsed_graph_ma)$frequency,
    display_category = V(collapsed_graph_ma)$display_category,
    label = V(collapsed_graph_ma)$label,
    fontface = V(collapsed_graph_ma)$fontface,
    node_type = V(collapsed_graph_ma)$node_type,
    node_shape = V(collapsed_graph_ma)$node_shape
  ) %>%
  activate(edges) %>%
  dplyr::mutate(edge_category = E(collapsed_graph_ma)$edge_category)

graph_tbl_ma_layout_collapsed <- create_layout(
  graph_tbl_ma_collapsed,
  layout = "manual",
  x = layout_matrix_ma_collapsed[, 1],
  y = layout_matrix_ma_collapsed[, 2]
)

# Create collapsed mature adult network plot
p_ma <- ggraph(graph_tbl_ma_layout_collapsed) +
  geom_edge_link(aes(color = edge_category), alpha = 0.5) +
  geom_node_point(
  aes(
    size = frequency,
    color = display_category,
    shape = factor(node_shape)
  ),
  fill = alpha("white", 0.6),
  stroke = 1.5
) +
  geom_node_label(
    aes(label = label, fontface = fontface),
    na.rm = TRUE,
    repel = TRUE,
    label.size = 0.3,
    max.overlaps = Inf,
    label.r = unit(0.15, "lines"),
    fill = alpha("white", 0.7),
    color = "black",
    size = 3
  ) +
  scale_color_manual(
    values = category_palette,
    breaks = sort(names(category_palette)),
    name = "Node Category"
  ) +
  scale_shape_manual(
    values = c(`16` = 16, `21` = 21),
    name = "Node Type",
    labels = c(`16` = "individual", `21` = expression(italic("aggregate")))
  ) +
  scale_edge_color_manual(
    values = c(category_palette, "Cross-category" = "grey38"),
    breaks = c(sort(names(category_palette)), "Cross-category"),
    name = "Edge Category"
  ) +
  scale_size_continuous(
    name = "Frequency",
    limits = c(freq_min, freq_max),
    range = c(4, 9),
    breaks = c(500, 1000, 2000, 5000, 10000)
  ) +
  theme_void()

# Save mature adult collapsed network
ggsave(
  filename = "./network images/mature_adult_network_graph_collapsed.png",
  plot = p_ma,
  dpi = 600,
  width = 10,
  height = 8,
  units = "in"
)

print(p_ma)

cat("Mature adult collapsed network visualization completed:",
    "\nNodes:", vcount(collapsed_graph_ma),
    "\nEdges:", ecount(collapsed_graph_ma), "\n")
```

```{r senior collapsed network}
# Create senior network with skin and infection/parasites collapsed
# Shows age-related comorbidity patterns in elderly dogs

# Clean and filter significant pairs for senior network
raw_pairs_s <- significant_pairs_s %>%
  dplyr::mutate(
    Disease1 = map_chr(Disease1, clean_disease_name),
    Disease2 = map_chr(Disease2, clean_disease_name)
  )

# Build graph from senior pairs
raw_graph_s <- graph_from_data_frame(raw_pairs_s, directed = FALSE)

# Assign node attributes from frequency data
raw_categories_s <- disease_frequencies_s$Disease.Category[
  match(V(raw_graph_s)$name, as.character(disease_frequencies_s$Numerical.Codes))
]

V(raw_graph_s)$display_category <- ifelse(
  raw_categories_s %in% fixed_categories,
  raw_categories_s,
  "Other"
)

V(raw_graph_s)$frequency <- disease_frequencies_s$frequency[
  match(V(raw_graph_s)$name, as.character(disease_frequencies_s$Numerical.Codes))
]

# Get node labels and apply replacements
node_labels_s <- disease_frequencies_s$Disease.Name[
  match(V(raw_graph_s)$name, as.character(disease_frequencies_s$Numerical.Codes))
]

node_labels_s <- dplyr::recode(node_labels_s, !!!label_replacements)
V(raw_graph_s)$label <- node_labels_s

# Define categories to collapse in senior network
collapse_categories_s <- c("Skin", "Infection/Parasites")

node_id_s <- V(raw_graph_s)$name
collapse_category_s <- ifelse(
  raw_categories_s %in% collapse_categories_s,
  raw_categories_s,
  node_id_s
)

V(raw_graph_s)$collapse_category <- collapse_category_s

# Contract graph to create collapsed nodes
group_ids_s <- as.numeric(as.factor(collapse_category_s))

collapsed_graph_s <- contract(
  raw_graph_s,
  mapping = group_ids_s,
  vertex.attr.comb = list(
    frequency = "sum",
    display_category = "first",
    collapse_category = "first",
    label = function(x) x[1]
  )
)

V(collapsed_graph_s)$name <- V(collapsed_graph_s)$collapse_category

# Build labels for collapsed senior network
individual_names_s <- tibble(
  collapse_category = node_id_s,
  label = node_labels_s
) %>%
  filter(collapse_category == collapse_category_s)

aggregate_categories_s <- setdiff(
  unique(V(collapsed_graph_s)$collapse_category),
  individual_names_s$collapse_category
)

aggregate_names_s <- tibble(
  collapse_category = aggregate_categories_s,
  label = aggregate_categories_s
)

complete_labels_s <- bind_rows(individual_names_s, aggregate_names_s)

V(collapsed_graph_s)$label <- complete_labels_s$label[
  match(V(collapsed_graph_s)$collapse_category, complete_labels_s$collapse_category)
]

# Style nodes based on type (individual vs aggregate)
V(collapsed_graph_s)$node_type <- ifelse(
  V(collapsed_graph_s)$collapse_category %in% collapse_categories_s,
  "aggregate", "individual"
)

V(collapsed_graph_s)$fontface <- ifelse(
  V(collapsed_graph_s)$node_type == "aggregate",
  "italic", "plain"
)

V(collapsed_graph_s)$node_shape <- ifelse(
  V(collapsed_graph_s)$node_type == "aggregate",
  21, 16
)

# Add collapse metadata for reference
collapse_map_tbl_s <- tibble(
  node_id = node_id_s,
  collapse_category = collapse_category_s
)

collapsed_sizes_s <- collapse_map_tbl_s %>%
  group_by(collapse_category) %>%
  summarise(num_diseases_collapsed = n(), .groups = "drop")

original_ids_s <- collapse_map_tbl_s %>%
  group_by(collapse_category) %>%
  summarise(original_node_ids = paste(node_id, collapse = ", "), .groups = "drop")

V(collapsed_graph_s)$num_diseases_collapsed <- collapsed_sizes_s$num_diseases_collapsed[
  match(V(collapsed_graph_s)$collapse_category, collapsed_sizes_s$collapse_category)
]

V(collapsed_graph_s)$original_node_ids <- original_ids_s$original_node_ids[
  match(V(collapsed_graph_s)$collapse_category, original_ids_s$collapse_category)
]

# Compute edge categories safely
edge_pairs_s <- igraph::ends(collapsed_graph_s, E(collapsed_graph_s), names = FALSE)

edge_categories_s <- apply(edge_pairs_s, 1, function(pair) {
  cat1 <- V(collapsed_graph_s)$display_category[pair[1]]
  cat2 <- V(collapsed_graph_s)$display_category[pair[2]]

  if (is.na(cat1) || is.na(cat2)) {
    return("Unknown")
  }

  if (cat1 == cat2) cat1 else "Cross-category"
})

E(collapsed_graph_s)$edge_category <- edge_categories_s

# Create layout and tidygraph representation
layout_matrix_s <- layout_with_fr(collapsed_graph_s)

graph_tbl_s <- as_tbl_graph(collapsed_graph_s) %>%
  activate(nodes) %>%
  dplyr::mutate(
    frequency = V(collapsed_graph_s)$frequency,
    display_category = V(collapsed_graph_s)$display_category,
    label = V(collapsed_graph_s)$label,
    fontface = V(collapsed_graph_s)$fontface,
    node_type = V(collapsed_graph_s)$node_type,
    node_shape = V(collapsed_graph_s)$node_shape
  ) %>%
  activate(edges) %>%
  dplyr::mutate(edge_category = E(collapsed_graph_s)$edge_category)

graph_tbl_layout_s <- create_layout(
  graph_tbl_s,
  layout = "manual",
  x = layout_matrix_s[, 1],
  y = layout_matrix_s[, 2]
)

# Create collapsed senior network plot
p_senior <- ggraph(graph_tbl_layout_s) +
  geom_edge_link(aes(color = edge_category), alpha = 0.5) +
  geom_node_point(
    aes(
      size = frequency,
      color = display_category,
      shape = factor(node_shape)
    ),
    fill = alpha("white", 0.6),
    stroke = 1.5
  ) +
  geom_node_label(
    aes(label = label, fontface = fontface),
    na.rm = TRUE,
    repel = TRUE,
    label.size = 0.3,
    max.overlaps = Inf,
    label.r = unit(0.15, "lines"),
    fill = alpha("white", 0.7),
    color = "black",
    size = 3.5
  ) +
  scale_color_manual(
    values = category_palette,
    breaks = sort(names(category_palette)),
    name = "Node Category"
  ) +
  scale_shape_manual(
    values = c(`16` = 16, `21` = 21),
    name = "Node Type",
    labels = c(`16` = "individual", `21` = expression(italic("aggregate")))
  ) +
  scale_edge_color_manual(
    values = c(category_palette, "Cross-category" = "grey38"),
    breaks = c(sort(names(category_palette)), "Cross-category"),
    name = "Edge Category"
  ) +
  scale_size_continuous(
    name = "Frequency",
    limits = c(freq_min, freq_max),
    range = c(4, 9),
    breaks = c(500, 1000, 2000, 5000, 10000)
  ) +
  theme_void()

# Save senior collapsed network
ggsave(
  filename = "./network images/senior_network_graph_collapsed.png",
  plot = p_senior,
  dpi = 600,
  width = 10,
  height = 8,
  units = "in"
)

print(p_senior)

cat("Senior collapsed network visualization completed:",
    "\nNodes:", vcount(collapsed_graph_s),
    "\nEdges:", ecount(collapsed_graph_s), "\n")
```

```{r network overlap heatmap}
# Modify text size for the combined figure (optional)
p_heatmap <- p_heatmap + 
  theme(
    axis.text.x.top = element_text(angle = 45, hjust = 0, size = 20),
    axis.text.y = element_text(hjust = 1, size = 20),
    legend.title = element_text(size = 18),
    legend.text = element_text(size = 18)
  ) +
  guides(fill = guide_colorbar(title = "Shared Edges"))

```


```{r combined age stratified figure}
# Create the main publication figure combining age-stratified networks with overlap heatmap
# This shows network evolution across life stages and quantifies their relationships

# Extract legend from mature adult plot for shared legend
legend_ma <- get_legend(
  p_ma + 
    theme(legend.position = "right", legend.title = element_text(size = 16), legend.text = element_text(size = 14))
)

# Create clean versions without legends for the 2x2 grid
p_ya_clean <- p_ya + theme(legend.position = "none", 
                           plot.margin = margin(r = 20, b = 20, t = 20))
p_ma_clean <- p_ma + theme(legend.position = "none",
                                     plot.margin = margin(l = 20, b = 20, r = 20, t = 20))
p_s_clean <- p_senior + theme(legend.position = "none",
                              plot.margin = margin(r = 20, t = 20))
p_heatmap_clean <- p_heatmap + theme(legend.position = "none",
                                       plot.margin = margin(l = 20, t = 20, r = 20))

# Add panel labels to each plot
p_ya_labeled <- ggdraw(p_ya_clean) + 
  draw_label("a)", x = 0.02, y = 0.98, hjust = 0, vjust = 1, fontface = "bold", size = 28)

p_ma_labeled <- ggdraw(p_ma_clean) + 
  draw_label("b)", x = 0.02, y = 0.98, hjust = 0, vjust = 1, fontface = "bold", size = 28)

p_s_labeled <- ggdraw(p_s_clean) + 
  draw_label("c)", x = 0.02, y = 0.98, hjust = 0, vjust = 1, fontface = "bold", size = 28)

p_heatmap_labeled <- ggdraw(p_heatmap_clean) + 
  draw_label("d)", x = 0.02, y = 0.98, hjust = 0, vjust = 1, fontface = "bold", size = 28)

# Arrange 2x2 grid without legend
main_grid <- plot_grid(
  plot_grid(p_ya_labeled, p_ma_labeled, ncol = 2),
  plot_grid(p_s_labeled, p_heatmap_labeled, ncol = 2),
  ncol = 1
)

# Add the shared legend to create final publication figure
final_plot <- plot_grid(
  legend_ma,
  main_grid,
  rel_widths = c(0.15, 0.85)
)

# Save combined publication figure
ggsave(
  filename = "./network images/combined_2x2_with_heatmap_cowplot_legend.png",
  plot = final_plot,
  dpi = 600,
  width = 20,
  height = 18,
  units = "in"
)

ggsave(
  filename = "./network images/combined_2x2_with_heatmap_cowplot_legend.tiff",
  plot = final_plot,
  dpi = 600,
  width = 20,
  height = 18,
  units = "in",
  compression = "lzw"
)

print(final_plot)
cat("Combined age-stratified publication figure created and saved\n")
```
```{r directed network main graph}
# Create the main directed network visualization
# This shows temporal relationships with collapsed categories and directed edges

# Build directed graph from significant pairs
g_directed <- graph_from_data_frame(edges_directed, directed = TRUE)
g_directed <- delete_vertices(g_directed, degree(g_directed) == 0)

# Add node attributes using disease frequency data
V(g_directed)$disease_name <- disease_frequencies$Disease.Name[
  match(V(g_directed)$name, disease_frequencies$Numerical.Codes)
]
V(g_directed)$category <- disease_frequencies$Disease.Category[
  match(V(g_directed)$name, disease_frequencies$Numerical.Codes)
]
V(g_directed)$frequency <- disease_frequencies$frequency[
  match(V(g_directed)$name, disease_frequencies$Numerical.Codes)
]

# Determine which categories have sufficient nodes to keep separate
category_counts <- table(V(g_directed)$category)
keep_categories <- names(category_counts[category_counts > 3])

V(g_directed)$display_category <- ifelse(
  V(g_directed)$category %in% keep_categories,
  V(g_directed)$category,
  "Other"
)

# Apply label replacements for better readability
V(g_directed)$disease_name <- dplyr::recode(
  V(g_directed)$disease_name,
  !!!label_replacements
)

# Generate edge categories based on node categories
edge_list_directed <- as_edgelist(g_directed, names = FALSE)

edge_categories_directed <- apply(edge_list_directed, 1, function(edge) {
  cat1 <- V(g_directed)$display_category[edge[1]]
  cat2 <- V(g_directed)$display_category[edge[2]]
  if (!is.na(cat1) && !is.na(cat2) && cat1 == cat2) {
    return(cat1)
  } else {
    return("Cross-category")
  }
})
E(g_directed)$edge_category <- edge_categories_directed

# Save original graph before collapsing for subgraph creation
g_uncollapsed_directed <- g_directed

cat("Directed network main graph created:",
    "\nNodes:", vcount(g_directed),
    "\nDirected edges:", ecount(g_directed), "\n")
```

```{r directed network collapsing}
# Apply strategic node collapsing to the directed network
# Collapse "Skin" and "Infection/Parasites" categories into aggregate nodes

# Function to collapse nodes by category
collapse_category_directed <- function(g, category_name, agg_id) {
  nodes <- V(g)[display_category == category_name]$name
  g <- add_vertices(g, 1,
    name = agg_id,
    disease_name = paste(category_name, "(Aggregate)"),
    category = category_name,
    display_category = category_name,
    frequency = sum(V(g)$frequency[V(g)$name %in% nodes], na.rm = TRUE),
    label = NA
  )
  
  # Handle incoming edges
  for (node in nodes) {
    incoming <- incident(g, node, mode = "in")
    for (e in incoming) {
      from_node <- ends(g, e)[1]
      if (from_node != node) {
        g <- add_edges(g, c(from_node, agg_id), attr = list(edge_category = E(g)[e]$edge_category))
      }
    }
    
    # Handle outgoing edges  
    outgoing <- incident(g, node, mode = "out")
    for (e in outgoing) {
      to_node <- ends(g, e)[2]
      if (to_node != node) {
        g <- add_edges(g, c(agg_id, to_node), attr = list(edge_category = E(g)[e]$edge_category))
      }
    }
  }
  
  g <- delete_vertices(g, nodes)
  return(g)
}

# Collapse "Skin" and "Infection/Parasites" categories
g_directed <- collapse_category_directed(g_directed, "Skin", "skin_agg")
g_directed <- collapse_category_directed(g_directed, "Infection/Parasites", "infect_agg")

# Set all labels initially
V(g_directed)$label <- V(g_directed)$disease_name

# Remove labels for aggregate nodes and their neighbors to reduce clutter
agg_nodes <- c("skin_agg", "infect_agg")
agg_neighbors <- unique(unlist(neighborhood(g_directed, order = 1, nodes = agg_nodes, mode = "all")))
agg_neighbor_names <- V(g_directed)$name[agg_neighbors]
V(g_directed)$label <- ifelse(V(g_directed)$name %in% c(agg_nodes, agg_neighbor_names), NA, V(g_directed)$label)

# Mark aggregate nodes for different styling
V(g_directed)$is_aggregate <- V(g_directed)$name %in% c("skin_agg", "infect_agg")

cat("Directed network collapsing completed:",
    "\nCollapsed nodes:", vcount(g_directed),
    "\nAggregate nodes created:", sum(V(g_directed)$is_aggregate), "\n")
```

```{r create directed network plot}
# Create the main directed network visualization
# Shows temporal relationships with arrows indicating direction

# Convert to tidygraph for ggraph
tg_directed <- as_tbl_graph(g_directed) %>%
  mutate(
    disease_name = V(g_directed)$disease_name,
    frequency = V(g_directed)$frequency,
    display_category = V(g_directed)$display_category,
    is_aggregate = V(g_directed)$is_aggregate
  ) %>%
  activate(edges) %>%
  mutate(edge_category = E(g_directed)$edge_category)

# Create layout for directed network
layout_directed <- create_layout(tg_directed, layout = "fr")

# Create main directed network plot
p_directed <- ggraph(layout_directed) +
  geom_edge_link(
    aes(color = edge_category),
    alpha = 0.5,
    arrow = arrow(length = unit(3, "mm")),
    end_cap = circle(3, "mm")
  ) +
  geom_node_point(
  aes(
    size = frequency,
    color = display_category,
    shape = is_aggregate
  ),
  alpha = 0.9,
  stroke = 1.5
) +
  geom_node_label(
    aes(label = label),
    label.size = 0.3,
    label.r = unit(0.15, "lines"),
    fill = alpha("white", 0.7),
    color = "black",
    fontface = "plain",
    size = 3,
    repel = TRUE,
    na.rm = TRUE
  ) +
  scale_edge_color_manual(values = c(category_palette, "Cross-category" = "grey38"), name = "Edge Category") +
  scale_color_manual(values = category_palette, name = "Node Category") +
  scale_size_continuous(
    name = "Frequency",
    range = c(2, 7),
    breaks = c(1000, 5000, 10000, 20000)
  ) +
  scale_shape_manual(
  values = c(`TRUE` = 21, `FALSE` = 16),
  name = "Node Type",
  labels = c("FALSE" = "Individual", "TRUE" = "Aggregate")
) +
  theme_void()

ggsave(
  filename = "./network images/directed_12m.png",
  plot = p_directed,
  dpi = 600,
  width = 10,
  height = 8,
  units = "in"
)

print(p_directed)

cat("Main directed network plot created and saved\n")
```
```{r directed subgraph and combined figure}
# Create detailed subgraph and combined figure for directed network

# Get detailed subgraph of skin and infection/parasites
detailed_categories <- c("Skin", "Infection/Parasites")
core_nodes <- V(g_uncollapsed_directed)[display_category %in% detailed_categories]$name
neighbor_indices <- neighborhood(g_uncollapsed_directed, order = 1, nodes = core_nodes, mode = "all")
neighbor_names <- unique(unlist(lapply(neighbor_indices, \(x) V(g_uncollapsed_directed)$name[x])))
detailed_subgraph_nodes <- unique(c(core_nodes, neighbor_names))

subgraph_detailed <- induced_subgraph(g_uncollapsed_directed, vids = detailed_subgraph_nodes)

# Create detailed subgraph plot
tg_detailed <- as_tbl_graph(subgraph_detailed) %>%
  mutate(
    disease_name = V(subgraph_detailed)$disease_name,
    frequency = V(subgraph_detailed)$frequency,
    display_category = V(subgraph_detailed)$display_category,
    is_aggregate = FALSE
  ) %>%
  activate(edges) %>%
  mutate(edge_category = E(subgraph_detailed)$edge_category)

layout_detailed <- create_layout(tg_detailed, layout = "fr")

p_detailed <- ggraph(layout_detailed) +
  geom_edge_link(
    aes(color = edge_category),
    alpha = 0.5,
    arrow = arrow(length = unit(3, "mm")),
    end_cap = circle(3, "mm")
  ) +
  geom_node_point(
    aes(size = frequency, color = display_category, shape = is_aggregate),
    alpha = 0.9,
    stroke = 1.5
  ) +
  geom_node_label(
    aes(label = disease_name),
    label.size = 0.3,
    label.r = unit(0.15, "lines"),
    fill = alpha("white", 0.7),
    color = "black",
    size = 3,
    repel = TRUE,
    na.rm = TRUE
  ) +
  scale_edge_color_manual(values = c(category_palette, "Cross-category" = "grey38"), name = "Edge Category") +
  scale_color_manual(values = category_palette, name = "Node Category") +
  scale_size_continuous(name = "Frequency", range = c(2, 7), breaks = c(1000, 5000, 10000, 20000)) +
  scale_shape_manual(values = c(`TRUE` = 21, `FALSE` = 16), name = "Node Type") +
  theme_void()

# Create combined directed figure
p_directed_clean <- p_directed + theme(legend.position = "none", plot.margin = margin(b=20)) 
p_detailed_clean <- p_detailed + theme(legend.position = "none", plot.margin = margin(t=20))

shared_legend_directed <- cowplot::get_legend(
  p_directed + theme(legend.position = "right", legend.title = element_text(size = 16), legend.text = element_text(size = 14))
)

stacked_directed <- cowplot::plot_grid(p_directed_clean, p_detailed_clean, ncol = 1, rel_heights = c(1, 1))

labeled_stacked_directed <- cowplot::ggdraw(stacked_directed) +
  cowplot::draw_plot_label(
    label = c("a)", "b)"), x = c(0.01, 0.01), y = c(0.99, 0.49),
    hjust = 0, vjust = 1, fontface = "bold", size = 14
  )

combined_directed_plot <- cowplot::plot_grid(labeled_stacked_directed, shared_legend_directed, ncol = 2, rel_widths = c(4, 1))

# Save combined directed figure
ggsave("./network images/combined_directed.tiff", combined_directed_plot, dpi = 600, width = 12, height = 14, units = "in", compression = "lzw")
ggsave("./network images/combined_directed.png", combined_directed_plot, dpi = 600, width = 12, height = 14, units = "in")

print(combined_directed_plot)

```

```{r visualization summary}
# Create comprehensive summary of all visualizations produced
visualization_summary <- data.frame(
  Visualization = c(
    "Main Collapsed Network (Undirected)",
    "Ear Infection Subgraph", 
    "Combined Main Figure (Undirected)",
    "Young Adult Network",
    "Mature Adult Collapsed",
    "Senior Collapsed",
    "Network Overlap Heatmap",
    "Combined Age-Stratified Figure",
    "Main Directed Network",
    "Directed Subgraph Detail",
    "Combined Directed Figure"
  ),
  Description = c(
    "Main comorbidity network with collapsed categories and highlighted edges",
    "Detailed subgraph showing ear infection and all its connections",
    "Two-panel figure combining main network with ear infection detail",
    "Young adult life stage network with all nodes labeled",
    "Mature adult network with skin and infection/parasites collapsed",
    "Senior network with skin and infection/parasites collapsed", 
    "Heatmap showing edge overlap quantification between age groups",
    "2x2 grid combining all age networks with overlap analysis",
    "Directed network showing temporal relationships with collapsed categories",
    "Detailed view of skin and infection/parasites temporal connections",
    "Two-panel directed figure with main network and detail view"
  ),
  Network_Type = c(
    "Undirected", "Undirected", "Undirected", "Undirected", "Undirected", 
    "Undirected", "Undirected", "Undirected", "Directed", "Directed", "Directed"
  )
)

write.csv(visualization_summary, "./network images/comprehensive_visualization_summary.csv", row.names = FALSE)

cat("\n=== COMPREHENSIVE NETWORK VISUALIZATION COMPLETE ===")
cat("\nBoth undirected and directed network visualizations created successfully.")
cat("\nTotal visualizations:", nrow(visualization_summary))
cat("\n  - Undirected networks:", sum(visualization_summary$Network_Type == "Undirected"))
cat("\n  - Directed networks:", sum(visualization_summary$Network_Type == "Directed"), "\n")
```






