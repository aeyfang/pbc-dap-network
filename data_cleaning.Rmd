---
title: "data_clean"
author: "Antoinette Fang"
date: "2024-07-13"
output: html_document
---

```{r setup}
# Load required packages
library(tidyverse)  # For data manipulation and visualization
library(fastDummies)  # For creating dummy variables
library(miceadds)  # For loading RData files
library(haven)  # For working with labelled data

# Create necessary output directories if they don't exist
dir.create("./clean data", showWarnings = FALSE, recursive = TRUE)
dir.create("./frequency tables", showWarnings = FALSE, recursive = TRUE)
```

```{r data import}
# Import source files from the Dog Aging Project
# Load survey data from DAP 2021 Curated Data Release
load.Rdata(filename="./DAP_2021_HLES_health_conditions_v1.0.RData", objname = "health_condition")
load.Rdata(filename = "./DAP_2021_HLES_cancer_conditions_v1.0.RData", objname = "cancer_condition")
load.Rdata(filename = "./DAP_2021_HLES_dog_owner_v1.0.RData", objname = "dog_owner")

# Load crosswalk between DAP disease codes and numerical codes
# This file is found in the GitHub repo
disease_code<-read.csv(file = "./diseaseCodes.csv")

# Load correction files for non-cancer conditions 
# Owners were given the option to select "other" for each condition category and to give a written description for said condition. Some of these written descriptions can be recategorized as existing conditions in the survey.
# The following dataframes contain the necessary information to make these adjustments
# These files can be found in the GitHub repo
# Get all non-cancer correction file paths that match the pattern
non_cancer_correction_files <- list.files(path = "./written description non cancer", 
                               pattern = "^written_description_non_cancer.+\\.csv$", 
                               full.names = TRUE)

# Extract the unique part of each filename to use as the dataframe name
# Remove the common prefix and file extension
non_cancer_correction_names <- gsub("written_description_non_cancer - |\\.csv", "", basename(non_cancer_correction_files))

# Load each file into its own dataframe with the distinctive name
for (i in seq_along(non_cancer_correction_files)) {
  # Create the assignment expression that will load each CSV into its own dataframe
  assign(non_cancer_correction_names[i], 
         read.csv(non_cancer_correction_files[i], stringsAsFactors = FALSE))
}

# Load correction files for cancer conditions 
# The same issues described above also occurred in the cancer condition dataframes
# The following dataframes contain the necessary information to make these adjustments
# These files can be found in the GitHub repo
# Get all cancer correction file paths that match the pattern
non_cancer_correction_files <- list.files(path = "./written description cancer", 
                               pattern = "^written_description_cancer.+\\.csv$", 
                               full.names = TRUE)

# Extract the unique part of each filename to use as the dataframe name
# Remove the common prefix and file extension
non_cancer_correction_names <- gsub("written_description_cancer - |\\.csv", "", basename(non_cancer_correction_files))

# Load each file into its own dataframe with the distinctive name
for (i in seq_along(non_cancer_correction_files)) {
  # Create the assignment expression that will load each CSV into its own dataframe
  assign(non_cancer_correction_names[i], 
         read.csv(non_cancer_correction_files[i], stringsAsFactors = FALSE))
}

```

```{r data processing and merging}
# Process dog_owner dataframe
# Extract key demographic variables and convert to appropriate types
dog_owner <- dog_owner %>%
  dplyr::select(dog_id, dd_age_years, dd_weight_lbs, dd_breed_pure, dd_breed_pure_or_mixed, dd_sex, dd_spayed_or_neutered) %>%
  mutate(
    dog_id = as.character(dog_id),
    dd_age_years = as.numeric(dd_age_years),
    dd_weight_lbs = as.numeric(dd_weight_lbs),
    dd_breed_pure_or_mixed = dd_breed_pure_or_mixed - 1, # Convert to binary (0=purebred, 1=mixed)
    # Create combined sex/spay-neuter status variable (1-4)
    recode.sex = case_when(
      dd_sex == 2 & dd_spayed_or_neutered == "False" ~ 1, #female, unspayed
      dd_sex == 2 & dd_spayed_or_neutered == "True" ~ 2, #female, spayed
      dd_sex == 1 & dd_spayed_or_neutered == "False" ~ 3, #male, unneutered
      dd_sex == 1 & dd_spayed_or_neutered == "True" ~ 4 # male, neutered
    ),
    # Convert weight to kg and classify dogs by weight class
    weight_kg = dd_weight_lbs * 0.453592,  # Convert lbs to kg
    weight_class = case_when(
      weight_kg < 10 ~ "toy/small",
      weight_kg < 20 ~ "medium",
      weight_kg < 30 ~ "standard",
      weight_kg < 40 ~ "large",
      TRUE ~ "giant"
    ),
    # Assign life stage based on age and weight class per DAP guidelines
    # Different weight classes age at different rates
    lifestage = case_when(
      (weight_class %in% c("toy/small", "medium", "standard") & dd_age_years <= 0.75) |
      (weight_class == "large" & dd_age_years <= 1) |
      (weight_class == "giant" & dd_age_years <= 1.5) ~ "puppy",
      (weight_class %in% c("toy/small", "medium", "standard") & dd_age_years > 0.75 & dd_age_years <= 3) |
      (weight_class == "large" & dd_age_years > 1 & dd_age_years <= 3) |
      (weight_class == "giant" & dd_age_years > 1.5 & dd_age_years <= 3) ~ "young adult",
      (weight_class %in% c("toy/small", "medium") & dd_age_years > 3 & dd_age_years <= 12) |
      (weight_class == "standard" & dd_age_years > 3 & dd_age_years <= 11) |
      (weight_class == "large" & dd_age_years > 3 & dd_age_years <= 10.5) |
      (weight_class == "giant" & dd_age_years > 3 & dd_age_years <= 9.5) ~ "mature adult",
      (weight_class %in% c("toy/small", "medium") & dd_age_years > 12) |
      (weight_class == "standard" & dd_age_years > 11) |
      (weight_class == "large" & dd_age_years > 10.5) |
      (weight_class == "giant" & dd_age_years > 9.5) ~ "senior",
      TRUE ~ NA_character_
    )
  ) %>%
  dplyr::select(-dd_sex, -dd_spayed_or_neutered) %>% #remove original spay/neuter and sex columns
  dummy_cols(select_columns = "recode.sex", remove_first_dummy = TRUE) # Create dummy variables for regression

```

```{r cancer condition processing}
# Process cancer_condition dataframe
# Filter out non-cancerous conditions that were incorrectly reported as cancer
cancer_condition <- cancer_condition %>%
  filter(!str_detect(tolower(hs_cancer_types_other_description), 
                     "benign|not cancer|no cancer|non cancerous|non-cancerous|fatty tumor|non malignant|non-malignant|not malignant|not known|don't know|unknown|not|non|no") |
           is.na(hs_cancer_types_other_description)) %>%
  dplyr::select(dog_id, hs_initial_diagnosis_year, hs_initial_diagnosis_month, 
         starts_with("hs_cancer_types")) %>%
  dplyr::select(-hs_cancer_types_other_description) %>%
  mutate(dog_id = as.character(dog_id))

# Standardize cancer type variables to binary format (0/1)
cancer_condition <- cancer_condition %>%
  mutate(across(starts_with("hs_cancer_types"), 
                ~case_when(
                  tolower(as.character(.)) %in% c("true", "1") ~ 1,
                  tolower(as.character(.)) %in% c("false", "0") ~ 0,
                  is.na(.) ~ 0,
                  TRUE ~ NA_real_
                )))

# Function to apply cancer condition corrections
apply_cancer_correction <- function(cancer_condition, correction_df) {
  # Get list of dog_ids to correct
  dogs_to_correct <- correction_df$dog_id
  
  # For each dog that needs correction
  for (dog_id in dogs_to_correct) {
    # Find the row index in cancer_condition for this dog
    row_idx <- which(cancer_condition$dog_id == dog_id)
    
    # Find the corresponding row in correction_df
    correction_row <- correction_df[correction_df$dog_id == dog_id, ]
    
    # Get all cancer type columns (those starting with "hs_cancer_types_")
    cancer_cols <- grep("^hs_cancer_types_", names(correction_row), value = TRUE)
    
    # Remove values from "unknown" and "other" columns first
    if ("hs_cancer_types_unknown" %in% names(cancer_condition)) {
      cancer_condition[row_idx, "hs_cancer_types_unknown"] <- 0
    }
    if ("hs_cancer_types_other" %in% names(cancer_condition)) {
      cancer_condition[row_idx, "hs_cancer_types_other"] <- 0
    }
    
    # Apply the corrections by copying values from correction_df to cancer_condition
    for (col in cancer_cols) {
      # Only update if the correction value is 1
      if (correction_row[[col]] == 1) {
        
        # Make sure the column exists in cancer_condition
        if (col %in% names(cancer_condition)) {
          cancer_condition[row_idx, col] <- 1
        } 
      }
    }
  }
  
  return(cancer_condition)
}

cancer_condition <- apply_cancer_correction(cancer_condition, hema_cancer) # Apply hematopoeitic cancer corrections
cancer_condition <- apply_cancer_correction(cancer_condition, bone_cancer) # Apply bone cancer corrections
cancer_condition <- apply_cancer_correction(cancer_condition, kidney_cancer) # Apply kidney/urinary cancer corrections
cancer_condition <- apply_cancer_correction(cancer_condition, repro_cancer) # Apply reproductive cancer corrections
cancer_condition <- apply_cancer_correction(cancer_condition, cancer_cancer) # Apply cancer corrections
cancer_condition <- apply_cancer_correction(cancer_condition, eye_cancer) # Apply eye cancer corrections
cancer_condition <- apply_cancer_correction(cancer_condition, skin_cancer) # Apply skin cancer corrections
```

```{r correcting health condition misclassification}
# Function to correct misclassified health conditions in the health_condition dataframe
correct_health_conditions <- function(health_condition, correction_df, category_code) {
  # Ensure dog_id is character type in both dataframes
  health_condition <- health_condition %>% 
    mutate(dog_id = as.character(dog_id))
  
  correction_df <- correction_df %>% 
    mutate(dog_id = as.character(dog_id))
  
  # Create the pattern to match the "other" category codes (category_code+98)
  other_code_pattern <- paste0("^", category_code, "98$")
  
  # For each dog in the correction dataframe
  for (i in 1:nrow(correction_df)) {
    current_dog_id <- correction_df$dog_id[i]
    correct_condition_code <- correction_df$hs_condition[i]
    
    # Check if the dog already has an entry with the correct condition code
    # Using sum() > 0 instead of any() to handle NA values properly
    already_has_correct_entry <- sum(
      health_condition$dog_id == current_dog_id & 
      health_condition$hs_condition == correct_condition_code, 
      na.rm = TRUE
    ) > 0
    
    # Find the rows in health_condition for this dog that have the "other" code
    rows_to_modify <- which(
      health_condition$dog_id == current_dog_id & 
      grepl(other_code_pattern, health_condition$hs_condition)
    )
    
    if (length(rows_to_modify) > 0) {
      if (already_has_correct_entry) {
        # If the dog already has the correct entry, delete the "other" entry
        health_condition <- health_condition[-rows_to_modify, ]
      } else {
        # Otherwise, replace the "other" code with the correct specific code
        health_condition$hs_condition[rows_to_modify] <- correct_condition_code
      }
    }
  }
  
  # Return the health_condition dataframe with corrections applied
  return(health_condition)
}

# Apply correction function for each condition category
health_condition <- correct_health_conditions(health_condition, bone_non_cancer, "11") # Apply bone/orthopedic condition corrections
health_condition <- correct_health_conditions(health_condition, brain_non_cancer, "12") # Apply brain/neurological condition corrections
health_condition <- correct_health_conditions(health_condition, cardiac_non_cancer, "5") # Apply cardiac condition corrections
health_condition <- correct_health_conditions(health_condition, endocrine_non_cancer, "13") # Apply endocrine condition corrections
health_condition <- correct_health_conditions(health_condition, ent_non_cancer, "2") # Apply ear/nose/throat condition corrections
health_condition <- correct_health_conditions(health_condition, gastro_non_cancer, "7") # Apply gastrointestinal condition corrections
health_condition <- correct_health_conditions(health_condition, hema_non_cancer, "14") # Apply hematopoeitic condition corrections
health_condition <- correct_health_conditions(health_condition, immune_non_cancer, "19") # Apply immune-mediated condition corrections
health_condition <- correct_health_conditions(health_condition, infection_non_cancer, "16") # Apply infection/parasites condition corrections
health_condition <- correct_health_conditions(health_condition, kidney_non_cancer, "9") # Apply kidney/urinary condition corrections
health_condition <- correct_health_conditions(health_condition, liver_non_cancer, "8") # Apply liver/pancreas condition corrections
health_condition <- correct_health_conditions(health_condition, mouth_non_cancer, "3") # Apply mouth/dental/oral condition corrections
health_condition <- correct_health_conditions(health_condition, repro_non_cancer, "10") # Apply reproductive condition corrections
health_condition <- correct_health_conditions(health_condition, respiratory_non_cancer, "6") # Apply respiratory condition corrections
health_condition <- correct_health_conditions(health_condition, toxin_non_cancer, "17") # Apply toxin consumption condition corrections
health_condition <- correct_health_conditions(health_condition, eye_non_cancer, "1") # Apply eye condition corrections
health_condition <- correct_health_conditions(health_condition, skin_non_cancer, "4") # Apply skin condition corrections
```

```{r health condition processing}
# Transform health_condition data from long to wide format for analysis
# Each row will represent one dog with binary indicators for each condition
health_condition_wide <- health_condition %>%
  filter(!is.na(hs_condition)) %>%
  dplyr::select(dog_id, hs_condition) %>%
  distinct() %>%
  mutate(present = 1,  # Create binary indicator (1 = condition present)
         dog_id = as.character(dog_id)) %>% 
  pivot_wider(
    id_cols = dog_id,
    names_from = hs_condition,
    names_prefix = "condition_",
    values_from = present,
    values_fill = 0  # Fill missing values with 0 (condition not present)
  ) %>%
  mutate(across(everything(), ~replace_na(., 0))) %>%
  {
    # Ensure condition columns are in numerical order
    condition_cols <- grep("^condition_", names(.), value = TRUE)
    sorted_condition_cols <- sort(as.numeric(sub("^condition_", "", condition_cols)))
    sorted_condition_cols <- paste0("condition_", sorted_condition_cols)
    
    dplyr::select(., dog_id, all_of(sorted_condition_cols), everything())
  }

```

```{r merge and straatify data}
# Combine dog demographics, cancer conditions, and health conditions
merged_data <- dog_owner %>%
  left_join(cancer_condition, by = "dog_id") %>%
  left_join(health_condition_wide, by = "dog_id")

# Replace any remaining NA values with 0 for disease indicators
merged_data <- merged_data %>%
  mutate(across(everything(), ~replace_na(., 0)))

# Split data into age cohorts for stratified analysis
lifestage_strata <- merged_data %>%
  group_by(lifestage) %>%
  group_split()

# Name each stratum for easier reference
names(lifestage_strata) <- c("mature_adult", "puppy", "senior", "young_adult")
```

```{r data cleaning function}
# Function to filter data based on study inclusion criteria
# 1. Keep only conditions with >=60 affected dogs
# 2. Include only dogs with at least one condition
clean_data <- function(data) {
  # Identify columns with more than 60 dogs
  disease_columns <- data %>%
    dplyr::select(starts_with("hs_cancer_types"), starts_with("condition_")) %>%
    names()
  columns_to_keep <- disease_columns[colSums(data[, disease_columns] == 1, na.rm = TRUE) >= 60]
  
  # Keep only the identified columns and the original dog_owner columns
  columns_to_keep <- c(names(dog_owner), "hs_initial_diagnosis_year", "hs_initial_diagnosis_month", columns_to_keep)
  
  data <- data %>% 
    dplyr::select(all_of(columns_to_keep)) %>%
    # Remove dogs with no diseases
    filter(if_any(c(starts_with("hs_cancer_types"), starts_with("condition_")), ~. == 1)) %>%
    mutate(
      total_diseases = rowSums(dplyr::select(., starts_with("condition_") | starts_with("hs_cancer_")))
    )
  
  return(data)
}
```

```{r apply study criteria and save data}
# Save full dataset including dogs with no diseases
write.csv(merged_data, "./clean data/merged_data_with_healthy_dogs.csv", row.names = FALSE)

# Apply filtering criteria to original dataset
merged_data_cleaned <- clean_data(merged_data)

# Apply criteria to each lifestage stratum
lifestage_strata_cleaned <- lapply(lifestage_strata, clean_data)

# Write the cleaned original dataset to CSV
write.csv(merged_data_cleaned, "./clean data/cleaned_unstrat.csv", row.names = FALSE)

# Write each cleaned stratum to a separate CSV file with simplified naming
walk2(names(lifestage_strata_cleaned), lifestage_strata_cleaned, 
      ~write.csv(.y, paste0("./clean data/cleaned_", .x, ".csv"), row.names = FALSE))
```


```{r generate disease frequency tables}
# Function to create frequency counts for all diseases in dataset
generate_frequency_table <- function(data, suffix = "") {
  # Count occurrences of each disease
  raw_disease_counts <- data %>%
    dplyr::select(starts_with(c("condition_", "hs_cancer_types_"))) %>%
    summarise(across(everything(), sum)) %>%
    pivot_longer(everything(), names_to = "code", values_to = "frequency") %>%
    mutate(code = str_remove(code, "condition_"))
  
  # Join with disease code lookup table to get disease names and categories
  disease_frequencies <- disease_code %>%
    inner_join(raw_disease_counts, by = c("Code.from.DAP.data" = "code")) %>%
    dplyr::select('Code.from.DAP.data', 'Numerical.Codes', 'Disease.Name', 'Disease.Category', 'frequency') %>%
    arrange(desc(frequency))
  
  # Save frequency table to CSV
  write.csv(disease_frequencies, paste0("./frequency tables/disease_frequencies", suffix, ".csv"), row.names = FALSE)
  
  return(disease_frequencies)
}

# Generate frequency table for overall dataset
overall_frequencies <- generate_frequency_table(merged_data_cleaned, "_unstrat")

# Generate frequency table for overall dataset
overall_frequencies <- generate_frequency_table(merged_data_cleaned, "_unstrat")

# Generate frequency tables for each stratum with simplified naming
strata_frequencies <- map2(lifestage_strata_cleaned, names(lifestage_strata_cleaned),
                           ~generate_frequency_table(.x, paste0("_", .y)))
```



