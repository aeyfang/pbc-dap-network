---
title: "data_analysis"
author: "Antoinette Fang"
date: "2024-07-21"
output: html_document
---


```{r load packages}
library(tidyverse)
library(caret)
library(writexl)
library(dplyr)
library(furrr)

# Set up parallel processing
plan(multisession)
```

```{r setup}
# import data 
data<-read.csv("./clean data/cleaned_all.csv")
disease_frequencies<-read.csv("./frequency tables/disease_frequencies_all.csv")
disease_frequencies <- disease_frequencies %>%
  mutate(Disease.Name = tolower(Disease.Name)) # Normalize to lowercase

# Sort data by a unique identifier
data <- data %>% arrange(dog_id)  # Assuming dog_id is a unique identifier

# Separate predictors
predictors <- data %>%
  dplyr::select(dd_age_years, dd_weight_lbs, dd_breed_pure_or_mixed,
         recode.sex_2, recode.sex_3, recode.sex_4)

# Separate response variables
responses <- data %>%
  dplyr::select(starts_with("condition_"), starts_with("hs_cancer_types"))
```

```{r helper functions}
# Function to get numerical code for cancer types
get_cancer_code <- function(cancer_type) {
  if (is.character(cancer_type) && startsWith(cancer_type, "hs_cancer_types_")) {
    cancer_name <- tolower(sub("hs_cancer_types_", "", cancer_type))
    code <- disease_frequencies %>%
      filter(Disease.Name == cancer_name) %>%
      pull(Numerical.Codes)
    return(if(length(code) == 0) cancer_type else as.numeric(code))
  }
  return(cancer_type)
}

# Function to clean disease names
clean_disease_name <- function(name) {
  if(startsWith(name, "condition_")) {
    return(sub("^condition_", "", name))
  } else if(startsWith(name, "hs_cancer_types_")) {
    return(get_cancer_code(name))
  }
  return(name)
}

# Function to calculate jacobian matrix for logistic regression
calculate_jacobian <- function(predictors, coefficients) {
  # Convert inputs to appropriate formats
  predictors <- as.matrix(predictors) 
  coefficients <- as.numeric(coefficients) 
  # Add intercept column to predictors
  predictors_with_intercept <- cbind(1, predictors) 
  linear_predictor <- predictors_with_intercept %*% coefficients 
  # Calculate derivative of inverse logit function
  deriv <- as.vector(exp(-linear_predictor) / (1 + exp(-linear_predictor))^2) 
  jacobian <- matrix(deriv, nrow = 1) %*% predictors_with_intercept / nrow(predictors)   
  return(jacobian)
}

# Function to calculate individual variances for each prediction
calculate_delta_variance <- function(predictors, coefficients, vcov_matrix) {
  # Convert inputs to appropriate formats
  predictors <- as.matrix(predictors)
  coefficients <- as.numeric(coefficients)
  vcov_matrix <- as.matrix(vcov_matrix)
  # Add intercept column
  predictors_with_intercept <- cbind(1, predictors)
  # Calculate linear predictor
  linear_predictor <- predictors_with_intercept %*% coefficients
  # Calculate derivative for each observation
  deriv <- exp(-linear_predictor) / (1 + exp(-linear_predictor))^2
  # Calculate individual variances
  variances <- sapply(1:nrow(predictors), function(i) {
    # Calculate jacobian for this observation
    jacobian <- matrix(deriv[i] * predictors_with_intercept[i,], nrow = 1)
    # Calculate variance for this observation
    var <- jacobian %*% vcov_matrix %*% t(jacobian)
    return(as.numeric(var))
  })
  return(variances)
}

# Create standardized disease lookup table
disease_lookup <- disease_frequencies %>%
  mutate(
    condition_code = paste0("condition_", Numerical.Codes),
    cancer_code = case_when(
      Disease.Category == "Cancer" ~ paste0("hs_cancer_types_", tolower(gsub(" ", "_", Disease.Name))),
      TRUE ~ NA_character_
    ),
    code = coalesce(cancer_code, condition_code)
  ) %>%
  dplyr::select(code, Disease.Name)
```

```{r LRM for each disease}
# Function to fit logistic regression and return coefficients and p-values
fit_logistic <- function(response, predictors) {
  model <- glm(response ~ ., data = predictors, family = binomial(link = "logit"))
  coef_summary <- summary(model)$coefficients
  result <- data.frame(
    Term = rownames(coef_summary),
    Coefficient = coef_summary[, "Estimate"],
    P_value = coef_summary[, "Pr(>|z|)"]
  )
  return(result)
}

# Fit models and combine results
model_results <- map(responses, ~fit_logistic(.x, predictors))
coef_pvalue_df <- do.call(rbind, lapply(names(model_results), function(disease) {
  df <- model_results[[disease]]
  df$Disease <- disease
  return(df)
}))

# Create wide format dataframe with coefficients and p-values
coef_pvalue_wide <- coef_pvalue_df %>%
  pivot_wider(
    id_cols = Disease,
    names_from = Term,
    values_from = c(Coefficient, P_value),
    names_glue = "{Term}_{.value}"
  )

# Reorder columns
col_order <- c("Disease",
               paste0("(Intercept)_", c("Coefficient", "P_value")),
               paste0(colnames(predictors), "_Coefficient"),
               paste0(colnames(predictors), "_P_value"))
coef_pvalue_wide <- coef_pvalue_wide[, col_order]

# Add disease names and save results
coef_pvalue_wide_named <- coef_pvalue_wide %>%
  left_join(disease_lookup, by = c("Disease" = "code")) %>%
  relocate(Disease.Name, .after = Disease)

write.csv(coef_pvalue_wide_named, 
          "./undirected network/disease_coefficients_and_pvalues_all.csv", 
          row.names = FALSE)

# Extract coefficients for further analysis
coef_df <- coef_pvalue_wide %>%
  dplyr::select(Disease, ends_with("_Coefficient")) %>%
  rename_with(~str_remove(., "_Coefficient"), ends_with("_Coefficient"))

coef_df_named <- coef_df %>%
  left_join(disease_lookup, by = c("Disease" = "code")) %>%
  relocate(Disease.Name, .after = Disease)

write.csv(coef_df_named, 
          "./undirected network/disease_coefficients_only_all.csv", 
          row.names = FALSE)
```

```{r calculate individual probabilities}
# Calculate risks and variances for all diseases
risk_scores <- map(names(responses), function(disease) {
  # Get response
  response <- responses[[disease]]
  
  # Fit logistic regression
  model <- glm(response ~ ., data = predictors, family = binomial(link = "logit"))
  
  # Calculate probabilities
  linear_pred <- predict(model, type = "link")
  probabilities <- 1 / (1 + exp(-linear_pred))
  
  # Get actual count for normalization
  actual_count <- sum(response)
  # Normalize probabilities
  scaling_factor <- actual_count / sum(probabilities)
  normalized_probs <- probabilities * scaling_factor
  
  # Calculate individual variances using delta method
  initial_variances <- calculate_delta_variance(predictors, coef(model), vcov(model))
  adjusted_variances <- initial_variances * scaling_factor^2
  
  list(
    probabilities = normalized_probs,
    variance = adjusted_variances
  )
})

# Extract probabilities and variances
risk_scores_df <- map(risk_scores, "probabilities") %>% 
  bind_cols() %>%
  setNames(names(responses))

variance_df <- map(risk_scores, "variance") %>% 
  bind_cols() %>%
  setNames(names(responses))

# Save results
write.csv(risk_scores_df, 
          "./undirected network/personalized_probability_all.csv", 
          row.names = FALSE)
write.csv(variance_df, 
          "./undirected network/personalized_probability_with_variance_all.csv", 
          row.names = FALSE)
```


```{r identify comorbid pairs}
# Function to calculate pair statistics
calculate_pair_statistics <- function(pair) {
  disease1 <- pair[1]
  disease2 <- pair[2]
  
  test_value <- sum(data[[disease1]] & data[[disease2]])
  
  risk1 <- risk_scores_df[[disease1]]
  risk2 <- risk_scores_df[[disease2]]
  var1 <- variance_df[[disease1]]
  var2 <- variance_df[[disease2]]
  
  expected_value <- sum(risk1 * risk2)
  unadjusted_var <- sum(risk1 * risk2 * (1 - risk1 * risk2))
  adjusted_var <- sum(var1 * risk2^2 + var2 * risk1^2 + var1 * var2)
  final_var <- unadjusted_var + adjusted_var
  
  z_score <- (test_value - expected_value) / sqrt(final_var)
  p_value <- 1 - pnorm(z_score)
  
  c(Disease1 = disease1,
    Disease2 = disease2,
    TestValue = test_value, 
    ExpectedValue = expected_value, 
    UnadjustedVariance = unadjusted_var,
    AdjustedVariance = adjusted_var, 
    FinalVariance = final_var, 
    PValue = p_value)
}

# Generate all pairs and calculate statistics in parallel
network_attributes <- future_map(
  combn(names(responses), 2, simplify = FALSE),
  calculate_pair_statistics,
  .options = furrr_options(seed = TRUE)
)

# Create network dataframe
network_df <- do.call(rbind, network_attributes) %>% 
  as.data.frame() %>%
  mutate(across(TestValue:PValue, as.numeric))

# Apply multiple testing correction
network_df$AdjustedPValue <- p.adjust(network_df$PValue, method = "bonferroni")

# Save all pairs with variances
write.csv(network_df, "./summary statistics/all_pairs_variances.csv")

# Filter significant pairs
significant_pairs <- network_df %>% 
  filter(AdjustedPValue < 0.001) %>%
  arrange(AdjustedPValue)

# Format significant pairs for Cytoscape
formatted_significant_pairs <- significant_pairs %>%
  mutate(
    Disease1 = sapply(Disease1, clean_disease_name),
    Disease2 = sapply(Disease2, clean_disease_name)
  ) %>%
  dplyr::select(Disease1, Disease2)

# Save results
write.csv(significant_pairs, 
          "./CSV network edges/significant_pairs_all.csv", 
          row.names = FALSE)
write_xlsx(formatted_significant_pairs, 
           "./network edges/formatted_pairs_all.xlsx")
```

```{r reference tables}
# Create final reference table with p-values
lookup_table <- formatted_significant_pairs %>%
  mutate(
    Disease1 = as.character(Disease1),
    Disease2 = as.character(Disease2)
  ) %>%
  # Create clean disease lookup to match our codes
  left_join(
    disease_frequencies %>%
      mutate(code = as.character(Numerical.Codes)) %>%
      dplyr::select(code, Disease.Name),  # Explicitly use dplyr::select
    by = c("Disease1" = "code")
  ) %>%
  rename(Disease1_name = Disease.Name) %>%
  left_join(
    disease_frequencies %>%
      mutate(code = as.character(Numerical.Codes)) %>%
      dplyr::select(code, Disease.Name),  # Explicitly use dplyr::select
    by = c("Disease2" = "code")
  ) %>%
  rename(Disease2_name = Disease.Name) %>%
  dplyr::select(Disease1, Disease1_name, Disease2, Disease2_name) %>%  # Explicitly use dplyr::select
  cbind(pval = significant_pairs$AdjustedPValue)

write.csv(lookup_table, 
          "./lookup tables/lookup_all.csv", 
          row.names = FALSE)

# Create comprehensive table with all statistics
comprehensive_table <- network_df %>%
  mutate(
    Disease1_key = sapply(Disease1, clean_disease_name),
    Disease2_key = sapply(Disease2, clean_disease_name)
  ) %>%
  # Join with disease frequencies for names
  left_join(
    disease_frequencies %>%
      mutate(code = as.character(Numerical.Codes)) %>%
      dplyr::select(code, Disease.Name),
    by = c("Disease1_key" = "code")
  ) %>%
  rename(Disease1_name = Disease.Name) %>%
  left_join(
    disease_frequencies %>%
      mutate(code = as.character(Numerical.Codes)) %>%
      dplyr::select(code, Disease.Name),
    by = c("Disease2_key" = "code")
  ) %>%
  rename(Disease2_name = Disease.Name) %>%
  dplyr::select(
    Disease1, Disease1_key, Disease1_name,
    Disease2, Disease2_key, Disease2_name,
    TestValue, ExpectedValue, 
    UnadjustedVariance, AdjustedVariance, FinalVariance,
    PValue, AdjustedPValue
  ) %>%
  arrange(AdjustedPValue)

write.csv(comprehensive_table, 
          "./CSV network edges/comprehensive_disease_pairs_all.csv", 
          row.names = FALSE)
```



