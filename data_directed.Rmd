---
title: "DAP_data_directional"
author: "Antoinette Fang"
date: "2023-02-26"
output: html_document
---


```{r setup}
library(tidyverse)  # For data manipulation and visualization
library(lubridate)  # For date handling
library(furrr)      # For parallel processing
library(haven)      # For reading SPSS/SAS data
library(readxl)     # For reading Excel files
library(writexl)    # For writing Excel files

# Set up parallel processing for faster computation
plan(multisession)

# Ensure all required directories exist

required_dirs <- c(
  "./clean data", 
  "./individual stats",
  "./pair stats", 
  "./directed network",
  "./Cytoscape inputs",
  "./frequency tables",
  "./reference tables"
)

# Create directories if they don't exist
for(dir in required_dirs) {
  if(!dir.exists(dir)) {
    dir.create(dir, recursive = TRUE)
    message(paste("Created directory:", dir))
  }
}

# Define the sliding window size in months
window_size <- 12 # change to 6, 24, etc. as needed
```

```{r data loading and prep}
# Read in data

# Load health condition data (from DAP project)
load("./DAP_2021_HLES_health_conditions_v1.0.RData")  
# Rename if needed
health_condition <- HLES_health_conditions  

# Load cancer condition data (from DAP project)
load("./DAP_2021_HLES_cancer_conditions_v1.0.RData")
cancer_condition <- HLES_cancer_conditions

# Standardize cancer type variables to binary format (0/1)
cancer_condition <- cancer_condition %>%
  mutate(across(starts_with("hs_cancer_types"), 
                ~case_when(
                  tolower(as.character(.)) %in% c("true", "1") ~ 1,
                  tolower(as.character(.)) %in% c("false", "0") ~ 0,
                  is.na(.) ~ 0,
                  TRUE ~ NA_real_
                )))

# Load dog owner data (from DAP project)
load("./DAP_2021_HLES_dog_owner_v1.0.RData")
dog_owner <- HLES_dog_owner

# Load previously processed data files
cleaned_data <- read.csv("./clean data/cleaned_unstrat.csv")
personalized_probability <- read.csv("./individual stats/probability_unstrat.csv")
personalized_probability <- cbind(dog_id = cleaned_data$dog_id, personalized_probability)
undirected_comorbid_pairs <- read_xlsx("./Cytoscape inputs/formatted_pairs_unstrat.xlsx")
disease_frequencies <- read_csv("./frequency tables/disease_frequencies_unstrat.csv")
```


```{r data prep}
# Create disease crosswalk
disease_mapping <- disease_frequencies %>%
  mutate(
    numerical_code = as.character(Numerical.Codes),  # just the number as string
    column_name = case_when(
      Disease.Category == "Cancer" ~ Code.from.DAP.data,               # e.g. "hs_cancer_types_lymphoma"
      TRUE ~ paste0("condition_", Numerical.Codes)                     # e.g. "condition_304"
    )
  ) %>%
  select(
    numerical_code,     # "304", "405", etc.
    column_name,        # "condition_304" or "hs_cancer_types_lymphoma"
    Disease.Name,
    Disease.Category
  )

# Clean health_condition
health_condition_clean <- health_condition %>%
  # Filter to dogs that are in cleaned_data
  filter(dog_id %in% cleaned_data$dog_id) %>%
  
  # Ensure hs_condition is numeric to match mapping
  mutate(hs_condition = as.numeric(hs_condition)) %>%
  
  # Keep only conditions in the frequency table (non-cancer)
  filter(hs_condition %in% disease_mapping$numerical_code[disease_mapping$Disease.Category != "Cancer"]) %>%
  
  # Format condition code and clean other fields
  mutate(
    dog_id = as.character(dog_id),
    numerical_code = as.numeric(hs_condition),
    hs_condition = paste0("condition_", hs_condition),
    hs_diagnosis_year = as.numeric(hs_diagnosis_year),
    hs_diagnosis_month = as.numeric(hs_diagnosis_month),
    source = "health"
  ) %>%
  select(dog_id, hs_condition, numerical_code,hs_diagnosis_year, hs_diagnosis_month, source)

# Get valid cancer condition column names
valid_cancer_conditions <- disease_mapping %>%
  filter(Disease.Category == "Cancer") %>%
  pull(column_name)

# Clean cancer_condition
cancer_condition_clean <- cancer_condition %>%
  # Step 1: Filter to dogs in cleaned_data
  filter(dog_id %in% cleaned_data$dog_id) %>%
  
  # Step 2: Pivot to long format to extract cancer types
  mutate(dog_id = as.character(dog_id)) %>%
  pivot_longer(
    cols = all_of(valid_cancer_conditions),  # Only columns that exist in mapping
    names_to = "hs_condition",
    values_to = "has_condition"
  ) %>%
  
  # Step 3: Keep only present conditions
  filter(has_condition == 1,
         hs_condition %in% valid_cancer_conditions) %>%
  
  # Step 4: Join to mapping and add numeric code
  left_join(disease_mapping, by = c("hs_condition" = "column_name")) %>%
  filter(!is.na(numerical_code)) %>%
  
  # Step 5: Format columns
  transmute(
    dog_id,
    hs_condition,  # this will be something like hs_cancer_types_lymphoma
    numerical_code,
    hs_diagnosis_year = as.numeric(hs_initial_diagnosis_year),
    hs_diagnosis_month = as.numeric(hs_initial_diagnosis_month),
    source = "cancer"
  )

# Coerce key columns in both data frames
health_condition_clean <- health_condition_clean %>%
  mutate(
    dog_id = as.character(dog_id),
    hs_condition = as.character(hs_condition),
    numerical_code = as.character(numerical_code)
  )

cancer_condition_clean <- cancer_condition_clean %>%
  mutate(
    dog_id = as.character(dog_id),
    hs_condition = as.character(hs_condition),
    numerical_code = as.character(numerical_code)
  )

# Combine both dataframes into one
all_conditions <- bind_rows(health_condition_clean, cancer_condition_clean)

# Remove duplicate entries
all_conditions <- all_conditions %>% distinct()
```


```{r medical history processing}
# Process all condition data to determine medical history length and diagnosis dates

# Function to safely convert values to numeric, handling labelled data
safe_as_numeric <- function(x) {
  if (inherits(x, "haven_labelled")) {
    return(as.numeric(x))
  } else {
    return(as.numeric(x))
  }
}

# Function to safely convert character dates to Date objects
safe_date_convert <- function(x) {
  if (inherits(x, "haven_labelled")) {
    x <- haven::zap_labels(x)
  }
  as_date(parse_date_time(x, orders = c("ymd", "mdy", "dmy")))
}

# Get dog ages from cleaned_data
dog_ages <- cleaned_data %>%
  mutate(dog_id = as.character(dog_id)) %>%
  dplyr::select(dog_id, dd_age_years) %>%
  mutate(dd_age_years = safe_as_numeric(dd_age_years))

# Get survey completion dates from dog_owner
survey_dates <- dog_owner %>%
  mutate(dog_id = as.character(dog_id)) %>%
  dplyr::select(dog_id, st_hles_completion_date) %>%
  mutate(st_hles_completion_date = safe_date_convert(st_hles_completion_date))

# Preprocess and filter all_conditions to valid diagnosis dates only
all_conditions_filtered <- all_conditions %>%
  mutate(across(c(hs_diagnosis_year, hs_diagnosis_month), safe_as_numeric)) %>%
  mutate(
    hs_diagnosis_year = if_else(hs_diagnosis_year < 1900 | hs_diagnosis_year > 2023, NA_real_, hs_diagnosis_year),
    hs_diagnosis_month = if_else(hs_diagnosis_month < 1 | hs_diagnosis_month > 12, NA_real_, hs_diagnosis_month),
    date = make_date(hs_diagnosis_year, hs_diagnosis_month, 1)
  ) %>%
  filter(!is.na(date))

# Summarize medical history for dogs with valid dates
medical_record_data <- all_conditions_filtered %>%
  group_by(dog_id) %>%
  summarise(
    earliest_date = min(date),
    latest_date = max(date),
    record_length_months = interval(earliest_date, latest_date) %/% months(1),
    valid_dates = n(),
    .groups = "drop"
  )

# Join and compute derived variables
final_data <- medical_record_data %>%
  inner_join(dog_ages, by = "dog_id") %>%
  inner_join(survey_dates, by = "dog_id") %>%
  mutate(
    years_since_latest_diagnosis = interval(latest_date, st_hles_completion_date) / years(1),
    age_at_latest_diagnosis = dd_age_years - years_since_latest_diagnosis
  )

# Clean and filter
check_data <- final_data %>%
  mutate(
    record_length_years = record_length_months / 12,
    age_at_latest_diagnosis = as.numeric(age_at_latest_diagnosis)
  ) %>%
  filter(
    record_length_years <= dd_age_years,
    age_at_latest_diagnosis >= 0,
    age_at_latest_diagnosis <= dd_age_years,
    record_length_years >= 0,
    record_length_years <= 25,
    valid_dates > 1,
    age_at_latest_diagnosis >= record_length_years
  ) %>%
  mutate(
    age_cat = cut(
      age_at_latest_diagnosis,
      breaks = c(0, 3, 6, 9, 12, 15, 18, 21, Inf),
      labels = c("0-3", "3-6", "6-9", "9-12", "12-15", "15-18", "18-21", "\u2265 21"),
      right = FALSE
    )
  )

# Save processed data
write.csv(check_data, "./directed network/diagnosis_date_data.csv", row.names = FALSE)

```

```{r visualize medical history}
# Create a boxplot showing medical record length vs. age at last recorded condition

# Boxplot of medical record length vs Age at Last Diagnosis
p <- ggplot(data = check_data, aes(x = age_cat, y = record_length_years, fill = age_cat)) +
  geom_boxplot() +
  labs(x = "Age at Last Recorded Health Condition (yrs)",
       y = "Medical Record Length (yrs)",
       fill = "Age Category") +
  theme_minimal() +
  theme(axis.title = element_text(size = 18),
        axis.text.x = element_text(size = 16),
        axis.text.y = element_text(size = 16),
        legend.position = "right",
        legend.title = element_text(size = 16),
        legend.text = element_text(size = 14)) +
  scale_fill_grey(start = 0.8, end = 0.2)

# Display the plot
print(p)

# Save the visualization
ggsave("./supplementary figures/S3_Fig.tiff", p, 
       width = 9, height = 6, dpi = 600, compression ="lzw")

saveRDS(p, file = "./medical_history_boxplot.rds")
```

```{r temporal data preparation}
# Ensure correct data types
all_conditions <- all_conditions %>%
  mutate(
    hs_diagnosis_year = as.numeric(hs_diagnosis_year),
    hs_diagnosis_month = as.numeric(hs_diagnosis_month),
    dog_id = as.numeric(dog_id)
  )

# These two are worth keeping for safety
cleaned_data <- cleaned_data %>%
  mutate(dog_id = as.numeric(dog_id))

personalized_probability <- personalized_probability %>%
  mutate(dog_id = as.numeric(dog_id))
```

```{r}
# ---- Utility: Map disease code to column name in cleaned_data ----
get_column_name <- function(disease_code) {
  col_name <- disease_mapping %>%
    filter(numerical_code == disease_code) %>%
    pull(column_name)

  if (length(col_name) == 0) {
    warning(paste("No mapping found for disease code:", disease_code))
    return(NULL)
  }
  return(col_name)
}

# ---- Utility: Get dog_ids with valid diagnosis for a given condition ----
get_dogs_with_condition <- function(condition, all_conditions) {
  all_conditions %>%
    filter(hs_condition == condition,
           !is.na(hs_diagnosis_year),
           !is.na(hs_diagnosis_month)) %>%
    pull(dog_id) %>%
    unique()
}

# ---- Utility: Extract diagnosis timing info for a given condition ----
get_temporal_data <- function(dogs, condition, all_conditions, suffix) {
  all_conditions %>%
    filter(dog_id %in% dogs, hs_condition == condition) %>%
    select(dog_id, hs_diagnosis_year, hs_diagnosis_month) %>%
    rename(!!paste0("year", suffix) := hs_diagnosis_year,
           !!paste0("month", suffix) := hs_diagnosis_month)
}

# ---- Main Function: Analyze one disease pair ----
# Analyze the temporal relationships between disease pairs
analyze_disease_pair <- function(disease1, disease2, 
                                 cleaned_data, 
                                 all_conditions, 
                                 personalized_probability, 
                                 disease_mapping, 
                                 window_size) {
  
  # Convert disease codes to proper column names in cleaned_data
  col1 <- get_column_name(disease1)
  col2 <- get_column_name(disease2)
  
  # Early exit if mapping not found
  if (is.null(col1) || is.null(col2)) {
    warning(paste("Could not map disease codes:", disease1, "or", disease2))
    return(NULL)
  }
  
  # Early exit if columns don't exist in cleaned_data
  if (!(col1 %in% colnames(cleaned_data)) || !(col2 %in% colnames(cleaned_data))) {
    warning(paste("Missing column(s):", col1, "or", col2))
    return(NULL)
  }

  # Find dogs with each condition using numerical_code for reliability
  dogs_disease1 <- all_conditions %>%
    filter(numerical_code == disease1,
           !is.na(hs_diagnosis_year), 
           !is.na(hs_diagnosis_month)) %>%
    pull(dog_id)
  
  dogs_disease2 <- all_conditions %>%
    filter(numerical_code == disease2,
           !is.na(hs_diagnosis_year), 
           !is.na(hs_diagnosis_month)) %>%
    pull(dog_id)
  
  # Identify dogs with both conditions
  dogs_with_both <- intersect(dogs_disease1, dogs_disease2)
  n_dogs_with_both = length(dogs_with_both)
  
  if (length(dogs_with_both) == 0) {
    warning(paste("No dogs found with both", disease1, "and", disease2))
    return(NULL)
  }
  
  # Extract temporal data for both conditions
  temporal_data1 <- all_conditions %>%
    filter(dog_id %in% dogs_with_both,
           numerical_code == disease1) %>%
    dplyr::select(dog_id, hs_diagnosis_year, hs_diagnosis_month) %>%
    mutate(year1 = hs_diagnosis_year, month1 = hs_diagnosis_month)
  
  temporal_data2 <- all_conditions %>%
    filter(dog_id %in% dogs_with_both,
           numerical_code == disease2) %>%
    dplyr::select(dog_id, hs_diagnosis_year, hs_diagnosis_month) %>%
    mutate(year2 = hs_diagnosis_year, month2 = hs_diagnosis_month)
  
  # Join temporal data
  temporal_data <- inner_join(temporal_data1, temporal_data2, by = "dog_id") %>%
    mutate(
      months_between = abs((year2 - year1) * 12 + (month2 - month1)),
      window_prob = case_when(
        months_between <= window_size ~ 1,
        TRUE ~ (window_size / months_between) * (2 - window_size / months_between)
      ),
      first_disease = if_else(
        year1 < year2 | (year1 == year2 & month1 <= month2),
        disease1, disease2
      )
    )
  
  # Pull personalized probabilities
  prob_data <- personalized_probability %>%
    filter(dog_id %in% dogs_with_both) %>%
    dplyr::select(dog_id, all_of(c(col1, col2))) %>%
    filter((!!sym(col1) + !!sym(col2)) > 0)

  # Get disease names
  disease1_name <- disease_mapping %>%
  filter(numerical_code == as.character(disease1)) %>%
  pull(Disease.Name) %>%
  { if (length(.) > 0) . else "Unknown" }

disease2_name <- disease_mapping %>%
  filter(numerical_code == as.character(disease2)) %>%
  pull(Disease.Name) %>%
  { if (length(.) > 0) . else "Unknown" }


  # Final result calculation
  results <- data.frame(
    disease1 = disease1,
    disease2 = disease2,
    disease1_name = disease1_name,
    disease2_name = disease2_name,
    n_dogs_with_both = n_dogs_with_both,
    expected_disease1_before_disease2 = sum(prob_data[[col1]] / (prob_data[[col1]] + prob_data[[col2]]) * temporal_data$window_prob),
    expected_disease2_before_disease1 = sum(prob_data[[col2]] / (prob_data[[col1]] + prob_data[[col2]]) * temporal_data$window_prob),
    variance_disease1_before_disease2 = sum(
      (prob_data[[col1]] / (prob_data[[col1]] + prob_data[[col2]]) * temporal_data$window_prob) * 
      (1 - prob_data[[col1]] / (prob_data[[col1]] + prob_data[[col2]]) * temporal_data$window_prob)
    ),
    variance_disease2_before_disease1 = sum(
      (prob_data[[col2]] / (prob_data[[col1]] + prob_data[[col2]]) * temporal_data$window_prob) * 
      (1 - prob_data[[col2]] / (prob_data[[col1]] + prob_data[[col2]]) * temporal_data$window_prob)
    ),
    count_disease1_first = sum((temporal_data$first_disease == disease1) * temporal_data$window_prob),
    count_disease2_first = sum((temporal_data$first_disease == disease2) * temporal_data$window_prob)
  )
  
  return(results)
}

# Iterate across all comorbidity pairs
direct_expected_counts <- future_map_dfr(1:nrow(undirected_comorbid_pairs), ~{
  disease_pair <- undirected_comorbid_pairs[.x, ]
  
  result <- analyze_disease_pair(
    disease1 = disease_pair$Disease1,
    disease2 = disease_pair$Disease2,
    cleaned_data = cleaned_data,
    all_conditions = all_conditions,
    personalized_probability = personalized_probability,
    disease_mapping = disease_mapping, 
    window_size = window_size
  )
  
  result  # If NULL, will be skipped
}, .options = furrr_options(seed = TRUE))

write.csv(
  direct_expected_counts,
  sprintf("./directed network/direct_expected_and_actual_counts_%dm.csv", window_size),
  row.names = FALSE
)
```



```{r calculate p-values}
# Calculate statistical significance for temporal relationships

# Calculate p-values and determine significance with bonferroni correction
results <- direct_expected_counts %>%
  mutate(
    # Calculate initial p-values for each direction
    # Tests whether observed count is significantly higher than expected
    p_value_1to2 = pnorm(count_disease1_first, 
                         mean = expected_disease1_before_disease2, 
                         sd = sqrt(variance_disease1_before_disease2), 
                         lower.tail = FALSE),
    p_value_2to1 = pnorm(count_disease2_first, 
                         mean = expected_disease2_before_disease1, 
                         sd = sqrt(variance_disease2_before_disease1), 
                         lower.tail = FALSE)
  ) %>%
  # Apply Bonferroni correction for multiple testing
  mutate(
    adj_p_value_1to2 = p.adjust(p_value_1to2, method = "bonferroni"),
    adj_p_value_2to1 = p.adjust(p_value_2to1, method = "bonferroni"),
    significant_1to2 = adj_p_value_1to2 < 0.01,
    significant_2to1 = adj_p_value_2to1 < 0.01
  )%>%
  mutate(
    se_1to2 = sqrt(variance_disease1_before_disease2),
    ci_lower_1to2 = expected_disease1_before_disease2 - 1.96 * se_1to2,
    ci_upper_1to2 = expected_disease1_before_disease2 + 1.96 * se_1to2,
    
    se_2to1 = sqrt(variance_disease2_before_disease1),
    ci_lower_2to1 = expected_disease2_before_disease1 - 1.96 * se_2to1,
    ci_upper_2to1 = expected_disease2_before_disease1 + 1.96 * se_2to1,
    
    # Flags to indicate whether actual count is outside CI
    outside_ci_1to2 = (count_disease1_first < ci_lower_1to2 | count_disease1_first > ci_upper_1to2),
    outside_ci_2to1 = (count_disease2_first < ci_lower_2to1 | count_disease2_first > ci_upper_2to1)
  )

# Create output for Cytoscape with both raw and adjusted p-values
# Extract only the significant directed edges
direct_significant_pairs <- results %>%
  # Create rows for significant 1->2 relationships using adjusted p-values
  {bind_rows(
    # When disease1 significantly precedes disease2
    filter(., significant_1to2) %>%
    dplyr::select(source = disease1, 
           target = disease2, 
           p_value = p_value_1to2,
           adjusted_p_value = adj_p_value_1to2),
    
    # When disease2 significantly precedes disease1
    filter(., significant_2to1) %>%
    dplyr::select(source = disease2, 
           target = disease1, 
           p_value = p_value_2to1,
           adjusted_p_value = adj_p_value_2to1)
  )} %>%
  arrange(adjusted_p_value)  # Sort by adjusted p-value

# Save formatted network attributes for Cytoscape
write_xlsx(
  direct_significant_pairs, 
  sprintf("./Cytoscape inputs/formatted_pairs_directed_%dm.xlsx", window_size)
)

```

```{r network attribute tables}
# Create crosswalk tables with disease names for visualization and analysis

# Create a lookup table for disease names 
disease_crosswalk <- disease_frequencies %>%
  dplyr::select(Code = `Numerical.Codes`, Disease.Name = `Disease.Name`) %>%
  mutate(Code = as.character(Code))  # Convert Code to character

# Add disease names to the Cytoscape edges
crosswalk_table <- direct_significant_pairs %>%
  mutate(
    source = as.character(source),  # Ensure source is character
    target = as.character(target)   # Ensure target is character
  ) %>%
  left_join(disease_crosswalk, by = c("source" = "Code")) %>%
  rename(source_name = Disease.Name) %>%
  left_join(disease_crosswalk, by = c("target" = "Code")) %>%
  rename(target_name = Disease.Name)

# Reorder columns
crosswalk_table <- crosswalk_table %>%
  dplyr::select(source, source_name, target, target_name, p_value)

write.csv(
  crosswalk_table, 
  sprintf("./reference tables/crosswalk_direct_%dm.csv", window_size), 
  row.names = FALSE
)


# Create comprehensive results with one row per direction
comprehensive_results <- results %>%
  {bind_rows(
    dplyr::select(., 
      disease1, disease2,
      raw_p_value = p_value_1to2,
      adjusted_p_value = adj_p_value_1to2,
      significant = significant_1to2,
      expected_count = expected_disease1_before_disease2,
      actual_count = count_disease1_first,
      variance = variance_disease1_before_disease2,
      ci_lower = ci_lower_1to2,
      ci_upper = ci_upper_1to2,
      outside_ci = outside_ci_1to2
    ) %>%
      mutate(
        source = disease1,
        target = disease2,
        direction = "forward"
      ),
    
    dplyr::select(., 
      disease1, disease2,
      raw_p_value = p_value_2to1,
      adjusted_p_value = adj_p_value_2to1,
      significant = significant_2to1,
      expected_count = expected_disease2_before_disease1,
      actual_count = count_disease2_first,
      variance = variance_disease2_before_disease1,
      ci_lower = ci_lower_2to1,
      ci_upper = ci_upper_2to1,
      outside_ci = outside_ci_2to1
    ) %>%
      mutate(
        source = disease2,
        target = disease1,
        direction = "reverse"
      )
  )} %>%
  left_join(disease_crosswalk, by = c("source" = "Code")) %>%
  rename(source_name = Disease.Name) %>%
  left_join(disease_crosswalk, by = c("target" = "Code")) %>%
  rename(target_name = Disease.Name) %>%
  dplyr::select(
    source, source_name,
    target, target_name,
    direction,
    raw_p_value,
    adjusted_p_value,
    significant,
    expected_count,
    actual_count,
    variance,
    ci_lower,
    ci_upper,
    outside_ci
  ) %>%
  arrange(raw_p_value)


write.csv(
  comprehensive_results, 
  sprintf("./pair stats/comprehensive_pairs_directed_%dm.csv", window_size), 
  row.names = FALSE
)

# Filter to only significant results
significant_comprehensive <- comprehensive_results %>%
  filter(significant)

# Save only significant pairs
write.csv(
  significant_comprehensive,
  sprintf("./pair stats/significant_pairs_directed_%dm.csv", window_size),
  row.names = FALSE
)

```


